# 浏览器渲染页面
浏览器内核：

Chrome，Safari--Webkit
Firefox--Gecko

浏览器还没有完整接受全部HTML文档时，它就已经开始显示页面了。

不同浏览器内核，渲染过程也不完全相同，但大致流程都差不多：

基本流程：（浏览器渲染页面.png）

根据 HTML 解析出 DOM 树
根据 CSS 解析生成 CSS 规则树
结合 DOM 树和 CSS 规则树，生成渲染树
根据渲染树计算每一个节点的信息
根据计算好的信息绘制页面

解析html以构建DOM树--》构建render渲染树--》布局渲染树--》绘制渲染树

HTML--》Script：阻塞后续，会先加载后面的CSS
HTML--》Style--》匹配规则--》CSS规则树
HTML--》容错机制，1）解码，2）预解析，3）符号化，4）构建树 --》DOM树

CSS规则树 + DOM树 --》 1.计算，2.级联 --》渲染树--》回流（reflow），重新渲染的过程
                                           --》1.节点的几何属性--》重绘（repaint）--》1。将像素发给GPU，2.GPU合并渲染层，3D加速--》显示

？？？浏览器首先会解析html文件构建DOM树，然后解析CSS文件构建渲染树，等渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。

6.1 HTML解析

浏览器解析html时，会“自上而下”加载，并在加载过程中进行解析渲染，解析的时候是从上而下一行一行解析的。

？？？在解析过程中，如果遇到请求外部资源，如图片，外链的css,iconfont等，请求过程是异步的，不会影响html文档进行加载。

解析过程可以分为4个步骤：
- **解码（encoding）**：传输回来的是一些二进制字节数据，浏览器需要根据文件指定编码（如UTF-8）转换成字符串，也就是HTML代码。
- **预解析（pre-parsing）**：提前加载资源，减少处理时间，它会识别一些会请求资源的属性，如img的src属性，并将这个请求加到请求队列中。
- **符号化（Tokenization）**：符号化是词法分析的过程，将输入解析成符号，HTML符号包括：开始标签，结束标签，属性名，属性值。它通过一个状态机去识别符号的状态，比如遇到<, >,状态都会发生变化
- **构建树（tree construction)**：符号化和构建树是并行操作的，只要解析到一个开始标签，就会创建一个DOM节点。

在符号化的过程中，解析器获得这些标记，然后以适当的方法创建DOM对象并把这些符号插入到DOM对象中。

**浏览器容错机制**
浏览器会纠正错误的语法，然后继续工作

**事件**
整个解析过程完成以后，浏览器会通过**DOMContentLoaded**事件来通知DOM解析完成。

6.2 CSS解析
一旦浏览器下载了CSS，CSS解析器就会处理它遇到的任何CSS，根据语法规范解析出所有的CSS并进行标记后，然后得到一个规则表。

**CSS标记规则**：在匹配一个节点对应的CSS规则时，是按从右到左的顺序的，如`div p { font-size : 14px}`会先寻找到所有的p标签，然后判断它的父元素是否为div

所以写CSS时，尽量使用id和class，避免过度层叠。

6.3 渲染树
其实是DOM树和CSS规则树合并的过程。 注：渲染树会忽略那些不需要渲染的节点，如设置来display:none的节点。

- 计算：通过计算让任何尺寸值都减少到三个可能之一：auto，百分比，px，比如把rem转化为px
- 级联：浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，使用`specificity`的公式，通过：1）标签名，class，id，2）是否内联样式，3）！important 得出一个权重值，取权重最高的一个
- 渲染阻塞：当遇到一个`script`标签时，DOM构建会被暂停，直至脚本完成执行，再继续构建DOM树。但如果JS依赖CSS样式，且它还没有被下载和构建时，浏览器就会延迟脚本执行，直至CSS Rules被构建。

文档加载过程中遇到JS文件，html文档会挂起渲染（加载/解析/渲染/同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。

  - CSS会阻塞JS执行
  - JS会阻塞后面的DOM解析
为避免，应该遵循以下原则：
  - CSS资源排在JS资源前面
  - JS放在HTML最底部，即body前；如果要改变阻塞模式，也可以使用 defer 和 async

6.4 布局和绘制
确定渲染树中所有节点的几何属性，如位置，大小等，最后输入一个盒子模型，它能精准捕获到每个元素在屏幕内的准确位置与大小。

  *DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小，这个过程是reflow；*

然后遍历渲染树，调用渲染器的paint（）方法在屏幕上显示其内容。

  *当盒模型的位置，大小及其它属性如颜色，字体等确定下来后，浏览器便开始绘制内容，这个过程是repaint。*

6.5 合并渲染层

把以上绘制的所有图片合并，最终输出一张图片

6.6 回流与重绘
- **回流（reflow）**：当浏览器发现某个部分变化影响了布局时，需要倒回去重新渲染，会从html标签开始递归向下，重新计算位置和大小。 reflow 基本是无法避免当，因为滑动一下鼠标，resize窗口，页面就会产生变化。 当渲染树中一部分因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，节点尺寸需要重新计算，表现为重新生成布局，重新排列元素
- **重绘（repaint)**：改变了某个元素的背景色，文字颜色等不会影响周围元素的位置变化时，就会发生重绘；渲染树中一些元素由于样式发生改变，需要更新（只影响外观，风格，不影响布局），例如改变元素背景色；每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。

重绘不一定出现重排，重排一定会出现重绘。

重排和重绘代价高昂，会破坏用户体验，让UI展示延迟，回流的成本比重绘要高很多，应尽量避免产生回流，无法避免时，一般选择重绘。


浏览器的渲染引擎将html代码根据css定义的规则，显示在浏览器窗口中的过程。
HTTP请求，DOM树构建，CSS计算，渲染，合成，绘制，自HTTP请求回来，就产生了流式的数据，后面的步骤都尽可能流式地处理前一步的输出，即不需要等到上一步骤完全结束，就开始处理上一步的输出。这样就会看到逐步出现的页面

1. 首先使用HTTP或HTTPS协议，向服务端请求页面
2. 将请求回来的html文件的代码经过解析，构建成DOM树
3. 计算DOM树上的CSS属性（进行CSS解析，生成Style Rules）
   （将DOM Tree和Style Rules合成为Render Tree；把不含样式信息的 DOM 树应用 CSS 规则，变成包含样式信息的 DOM 树)）
4. 根据CSS属性对元素逐个渲染，得到内存中的位图(根据样式和大小信息，为每个元素在内存中渲染它的图形)
5. Layout,排版布局（根据样式信息，计算了每个元素的位置和大小）
6. 一个可选的步骤是对位图进行合成，这会极大增加后续绘制的速度
7. Paint，合成之后，绘制到界面上（遍历Render Tree的节点，将元素绘制到对应的位置。）

CSS 计算是把 CSS 规则应用到 DOM 树上，为 DOM 结构添加显示相关属性的过程；
DOM去匹配css rule的时候head中的css已下载完成了，body中放CSS的话，会重新计算

在构造DOM树的过程中，依次拿到上一步构造好的元素，去检查它匹配了哪些规则，再根据规则的优先级，做覆盖和调整。

把 URL 变成字符流，把字符流变成词（token）流，把词（token）流构造成 DOM 树，把不含样式信息的 DOM 树应用 CSS 规则，变成包含样式信息的 DOM 树，并且根据样式信息，计算了每个元素的位置和大小。那么，我们最后的步骤，就是根据这些样式信息和大小信息，为每个元素在内存中渲染它的图形，并且把它绘制到对应的位置。

渲染：把每个元素对应的盒变成位图，一个元素可能对应多个盒，每个盒对应一张位图。

**排版**
浏览器确定（文字，图片，图形，表格）位置的过程，叫做排版。
最基本的排版方案，是**正常流**排版，包含了顺次排布和折行等规则。

文字排版，规定了行模型和文字在行模型中的排布。行模型规定了行顶，行底，文字区域，基线等对齐方式。
浏览器支持元素和文字的混排，元素被定义为占据长方形的区域，还允许边框，边距和留白，即所谓的 **“盒模型”**
根据盒模型，它占据的空间是由margin,border,padding,width/height等属性之和决定的
在正常流基础上，还支持两类元素：绝对定位元素，浮动元素
- 绝对定位元素把自身从正常流抽出，直接由top,left等确定自身位置，不参加排版计算，也不影响其他元素。由position控制。
需要根据它的包含块来确定位置，和正常流无关的一种独立排版模式，逐层找到父级的非static定位的元素
- 浮动元素，使得自己在正常流的位置向左或向右移动到边界，并占据一块排版空间，由float控制。
先排入正常流，再移动到排版宽度的最左/最右。

### DOM Tree是如何构建的
1. 转码：浏览器将接收到的字符流（二进制数据）按照指定编码格式转换为HTML字符串（Bytes->Characters，即< html>< head>......）
2. 生成Tokens：之后开始parse，将HTML字符串解析成Tokens(Characters->Tokens,token种类大约有标签开始，属性，标签结束，注释，CDATA节点)
3. 构建Nodes：对Node添加特定的属性，通过指针确定Node的父子兄弟关系和所属的TreeScope
4. 生成DOM Tree：通过node包含的指针确定的关系构建出DOM Tree，从父到子，从先到后，一个一个节点构造，并且挂载到 DOM 树上。

### 浏览器是如何判断元素是否匹配某个 CSS 选择器
CSS选择器的解析是**从右向左**解析的。

在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。

若从左向右的匹配，要遍历节点的子节点查找，如果发现不符合规则，需要进行回溯，会损失很多性能。

若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。

两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。

- **为什么通常推荐将 CSS < link> 放置在 < head>< /head> 之间，而将 JS < script> 放置在 < /body> 之前？你知道有哪些例外吗？**
浏览器以逐行方式对HTML文档进行解析，页面加载自上而下，css的下载解析可以和html的解析同步进行。
放到尾部，CSS还没加载完，DOM就已经绘制出来了，造成CSS加载解析完成后的重新渲染。
- **浏览器怎么加载页面的？script脚本阻塞有什么解决方法？请解释 < script >、< script async > 和 < script defer > 的区别。**
script会阻塞文档解析。
当浏览器解析到script的时候，就会立即下载执行，中断html的解析过程，如果外部脚本加载时间很长，就会造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。

流程：浏览器边下载HTML网页边解析；发现script标签，暂停解析，网页渲染的控制权转交给JavaScript引擎
如果script标签引用了外部脚本，就下载该脚本，否则就直接执行；执行完毕，控制权交还渲染引擎，恢复往下解析HTML网页

这两个属性只是script标签在header标签中使用的，如果你把它放在body后面是无效的。
浏览器解析HTML网页，发现带有defer/async的script，继续解析HTML，并行下载script中的外部脚本。
1. defer：浏览器指示脚本在文档被解析后执行，会在 DOMContentLoaded 事件之前（也就是页面DOM加载完成时），script异步加载后不会立刻执行，而是等文档被解析完毕后执行，会按照js脚本书写顺序执行。
2. async：异步加载脚本，脚本加载完毕后立即执行，这导致async属性下的脚本是乱序的，哪个脚本先下载结束，就先执行那个脚本，对script有先后依赖关系的情况不适用。

async和defer都是异步的，仅对外部脚本有效，对于内置的script标签，以及动态生成的script标签不起作用。

一般来说，如果脚本之间没有依赖关系，就使用async属性，如果脚本之间有依赖关系，就使用defer属性。如果同时使用async和defer属性，后者不起作用，浏览器行为由async属性决定。


## **重绘(Repaint)和回流(Reflow)/重排**
### 如何触发重排和重绘
任何对用来构建渲染树的信息的改变都会导致一次重排或重绘。
1. 添加、删除、更新DOM节点
2. display:none，隐藏DOM节点——重排和重绘
3. visibility:hidden，隐藏一个DOM节点——只触发重绘，因为没有几何变化
4. 移动或给页面中的DOM节点添加动画
5. 添加一个样式表，调整样式属性
6. 用户行为，如scroll，resize，改变字号

### 如何避免重绘或重排
1. 集中改变样式——通过改变class的方式集中改变样式，如theme的方式，直接改变className，如果动态改变样式，则使用cssText，el.style.cssText += ";
2. 让要操作的元素进行”离线处理”，处理完后一起更新。——使用DocumentFragment创建一个游离于DOM树之外的节点，在此节点上批量操作，最后加入DOM树中，只触发一次回流和重绘,进行缓存操作。document.createDocumentFragment，fragment.appendChild,最后再将fragment加入document.body
3. 提升为合成层
将元素提升为合成层有以下优点：
- 合成层的位图，会交由GPU合成，比CPU处理要快
- 需要repaint时，只需要repaint本身，不会影响到其它层
- 对transform和opacity效果，不会触发layout和paint

提升合成层的最好方式是使用CSS的will-change属性

- 浏览器布局、组合和绘制之间的区别。layout、painting 和 compositing。

**合成（compositing）**
渲染的过程不会把子元素渲染到位图上，合成的过程，就是为一些元素创建一个“合成层”，把一部分子元素渲染到合成的位图上面。目的是提高性能，最大限度减少绘制次数，是一个性能考量。

合成策略是“猜测”可能变化的元素，把它排除到合成之外。
浏览器一般根据position,transform等属性来决定合成策略，“猜测”哪些元素未来可能会变化。
新CSS标准中，规定了will-change属性，由业务代码来提示浏览器的合成策略，提升合成策略的效果。

### CSS3 will-change
属于web标准属性，作用就是 —— 增强页面渲染性能。

3D transform会启用GPU加速，如transform3D, scaleZ等，被称为 hack 加速法，因为实际上并不需要z轴的变化，这而是欺骗浏览器的做法。

当我们通过某些行为（点击、移动或滚动）触发页面进行大面积绘制的时候，浏览器往往是没有准备的，只能被动使用CPU去进行计算和重绘。由于没有事先准备，应付渲染够呛，容易掉帧、卡顿。

而will-change是在真正的行为触发之前告诉浏览器，浏览器就用GPU来应对变化。
```css
// 关键字值
will-change: auto;  // 和width:auto一样，没什么用
will-change: scroll-position; // 告诉浏览器，要进行scroll
will-change: contents; // 告诉浏览器，内容要动画或变化了
will-change: transform;  /* <custom-ident>示例 */
will-change: opacity; /* <custom-ident>示例 */
will-change: left, top; /* animateable-feature示例 */

// 全局值
will-change: inherit;
will-change: initial;
will-change: unset;

```

**< custom-ident >** 
自定义的识别，比如animation的名称，如transform，opacity，都是CSS3动画常用属性。如果给定的属性是缩写，则所有缩写相关属性变化都会触发。同时不能是以下这些关键字值：unset, initial, inherit, will-change, auto, scroll-position, 或 contents.

**< animateable-feature >** 
可动画的一些特征值，如left, top，margin之类的。移动端，非transform, opacity属性的动画性能都是低下的，所以都是建议避免使用left/top/margin之流进行位移等。

就目前而言，使用的基本上都是：
```css
.example {
  will-change: transform;
}
```

- 使用注意事项
will-change虽然可以加速，但是要适度使用。如果让浏览器很多元素都随时GPU渲染加速等待，代价会很大。

移动端的GPU加速，写CSS3动画的时候，或者静态属性的时候，动不动就把translateZ之类GPU hack属性写上，GPU提高页面渲染性能但是会影响手机电量。
一般的CSS动画，平常的渲染处理，手机都是可以比较流畅的。完全没有必要以牺牲其他东西来实现。

同样的，will-change的使用也要谨慎，遵循最小化影响原则

不要这样直接写在默认状态中，因为will-change会一直挂着：

```css
.will-change {
  will-change: transform;
  transition: transform 0.3s;
}
.will-change:hover {
  transform: scale(1.5);
}
```
可以让父元素hover的时候，声明will-change，这样，移出的时候就会自动remove，触发的范围基本上是有效元素范围。
```css
/* ????? 
不加这个属性，也会动态提升成合成层，然后动画结束，变成普通图层的 */
/* 因为提升成合成层的其中理由就是： */
/* 对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition（需要是 active 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效）。 */
.will-change-parent:hover .will-change {
  will-change: transform;
}
.will-change {
  transition: transform 0.3s;
}
.will-change:hover {
  transform: scale(1.5);
}
```
如果使用JS添加will-change, 事件或动画完毕，一定要及时remove. 比方说点击某个按钮，其他某个元素进行动画。点击按钮(click)，要先按下(mousedown)再抬起才触发。因此，可以mousedown时候打声招呼, 动画结束自带回调：
```javascript
dom.onmousedown = function() {
    target.style.willChange = 'transform';
};
dom.onclick = function() {
    // target动画哔哩哔哩...
};
target.onanimationend = function() {
    // 动画结束回调，移除will-change
    this.style.willChange = 'auto';
};
```

**绘制**
绘制是把“位图最终绘制到屏幕上，变成肉眼可见的图像”的过程，浏览器只需要把最终要显示的位图交给操作系统即可。
我们已经得到了每个元素的位图，并且对它们部分进行了合成，那么绘制过程，实际上就是按照 z-index 把它们依次绘制到屏幕上。


## 获取其他资源
浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等），在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。

这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等...

不像动态页面，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取，或者可以放到CDN中

- 浏览器解析过程
流程： 解析html以构建dom树->构建render树->布局render树->绘制render树
https://www.iefans.net/liulanqi-ruhe-gongzuo-yuanli/ 浏览器是如何工作的？

浏览器原理
1.各浏览器使用的 JavaScript引擎以及它们的异同点、如何在代码中进行区分

2.请求数据到请求结束与服务器进行了几次交互

4.浏览器解析 HTML代码的原理，以及构建 DOM树的流程

5.浏览器如何解析 CSS规则，并将其应用到 DOM树上

6.浏览器如何将解析好的带有样式的 DOM树进行绘制

7.浏览器的运行机制，如何配置资源异步同步加载

8.浏览器回流与重绘的底层原理，引发原因，如何有效避免
