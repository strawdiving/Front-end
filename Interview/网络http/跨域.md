## 跨域
同源策略(same-origin policy)，限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互，用来隔离潜在恶意文件。

同源是指：“协议+域名+端口”三者相同，即使两个相同的域名指向同一个IP，也非同源。
浏览器中大部分内容都是受同源策略限制，但三个标签可以不受限制：`img，link，script`

## 如何实现跨域
1. image PING

2. 通过jsonp跨域，JSONP 的工作原理，
jsonp的实现（要代码）方式；带超时，带防重名的 JSONP 的实现；

后台响应头要加什么？
Content-Type=text/javascript

它为什么不是真正的 Ajax？
- ajax的核心是通过XmlHttpRequest获取非本页内容
- jsonp的核心是动态添加< script >标签来调用服务器提供的js脚本

区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，字符串也行，只是不利于用jsonp提供公开服务

jsonp利用script标签（拥有src属性的标签都可以，如script,image,iframe）不受同源策略限制的特性进行跨域操作。实现简单，兼容性好；
缺点：只支持get请求，script只能get；易受xss攻击；需要服务端配合jsonp进行一定程度改造。

所以用纯前端的方式跨域访问数据只有一种可能，就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；

web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以json为后缀），服务器之所以要动态生成JSON文件，目的在于把客户端需要的数据装入进去。

客户端在对JSON文件调用成功后，获得了自己所需的数据。
JSONP的要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。
如何让服务端知道本地的函数名呢？只要服务端提供的js脚本是动态生成的就行了，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。

前端：1）定义callback函数，2）传入请求参数，3）动态生成script标签
example:
```javascript
    <script type="text/javascript">
    // 得到航班信息查询结果后的回调函数
    var flightHandler = function(data){
        alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');
    };
    // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）
    var url = "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&callback=flightHandler";
  code参数告知服务器要返回的数据，callback参数告知本地回调函数的名字，请把查询结果传入该函数中进行调用

    // 创建script标签，设置其属性
    var script = document.createElement('script');
    script.setAttribute('src', url);
    // 把script标签加入head，此时调用开始
    document.getElementsByTagName('head')[0].appendChild(script);
    </script>
```
服务端返回一个定制的js文件，调用callback函数并且将JSON 数据形式作为参数传递，文件内容：

flightHandler({
    "code": "CA1998",
    "price": 1780,
    "tickets": 5
});
传给flightHandler函数的是一个json。
Content-Type = text/javascript

实现：
```javascript
function JSONP({url,params,callbackKey,callback}) {
  window.jsonpCallback = callback
  const paramKeys = Object.keys(params)
  const paramString = paramKeys.map(key=>`${key} = ${params[key]}`).join('&'))

  const script = document.createElement('script')
  script.setAttribute('src','$(url).?${paramString}')
  document.body.appendChild(script)
}
JSONP({
    url:'http://sss.weibo.com',
    params: {key: 'test'},
    callbackKey: '_cb',
    callback(result) {console.log(result.data)} });
```

3. CORS,目前主流的跨域解决方案
用额外的HTTP头来告诉浏览器一个origin/domain上的web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从和该资源所在server不同的域请求一个资源时，资源会发起一个跨域HTTP请求。
如果用express，可以这样在后端设置：
```javascript
var allowCrossDomain = function(req,res,next) {
	res.header('Access-Control-Allow-Origin','http://example.com');
	res.header('Access-Control-Allow-Methods','GET,PUT,POST,DELETE');
	res.header('Access-Control-Allow-Headers','Content-Type');

	next()
}

app.configure(function() {
	...
	app.use(express.session({secret: 'cool beans'});
	app.use(allowCrossDomain));
	...
})
```

CORS 会从简单请求跟非简单请求区分开，再讲 options 请求的意义。
4. nginx反向代理,优点是轻量级，启动快，高并发。
我们用node开发的服务通常都要经过nginx的反向代理。

反向代理的原理：所有client的请求都必须先经过nginx的处理，nginx作为代理服务器再将请求转发给node服务，这样就规避了同源请求。不用目标服务器配合.

5. Websocket,websocket的工作原理和机制
一次http请求，目的是建立websocket通信，建立连接之后，Websocket的c和s都能主动向对方发送和接收数据，之间的通信和HTTP无关了，因此可以跨域。

6. 使用HTML5中新引进的window.postMessage方法来跨域传送数据（ie 67 不支持）
允许来自不同源的脚本采用异步方式进行有限的通信。可以跨文档，多窗口，跨域消息传递。

- 页面访问Cookie的限制条件
 1）跨域问题
 2）设置了HttpOnly
- web端cookie的设置和获取,cookie 结构有什么字段

## 跨域
跨域，为什么JS会对跨域做出限制，介绍下浏览器跨域，介绍同源策略
怎么去解决跨域问题，如何避免同源策略，几种方式的异同点以及如何选型
比较常用的跨域方法：CORS，proxy代理，Nginx反向代理

jsonp方案需要服务端怎么配合，jsonp为什么不支持post方法

CORS如何设置，加上CORS之后从发起到请求正式成功的过程
Access-Control-Allow-Origin在服务端哪里配置
ajax如何处理跨域，Ajax发生跨域要设置什么（前端）

开发环境一般用proxy代理，生产环境一般用Nginx代理

安全性——何时使用 JSONP、COR 和 iFrame。
