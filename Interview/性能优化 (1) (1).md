
## Web性能
- 什么是预加载、懒加载，何时预取和预加载资源；

预加就是将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。
在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。预加载是提前加载，会对服务器前端有一定压力

图片预先加载到浏览器中，访问者便可顺利地在你的网站上冲浪，并享受到极快的加载速度。这对图片画廊及图片占据很大比例的网站来说十分有利，它保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时获得更好的用户体验。


实现预加载的几种方法：
- 使用HTML标签，image对象
- 用CSS和JavaScript实现预加载；
- 仅使用JavaScript实现预加载；
- 使用Ajax实现预加载。 

常用的是new Image();设置其src来实现预载，再使用onload方法回调预载完成事件。只要浏览器把图片下载到本地，同样的src就会使用缓存，这是最基本也是最实用的预载方法。当Image下载完图片头后，会得到宽和高，因此可以在预载前得到图片的大小(方法是用记时器轮循宽高变化)。

懒加载，延迟加载甚至不加载，对服务器前端有一定的缓解压力作用

- 按需加载，不同页面的元素判断标准
- 延迟加载和捆绑拆分；
### 图片延迟加载,如何实现图片滚动懒加载
当访问一个页面的时候，想把img元素或是或是其他元素背景图片路径替换成一张大小为的图片的路径（这样只需请求一次俗称占位），才设置图片的真实路径，让图片显示出来，这就是图片懒加载。

如果没有src属性，浏览器就不会发出请求去下载图片，只有通过javascript设置了图片路径，浏览器才会发送请求。 懒加载的原理就是先在页面中把所有的图片统一使用一张占位图1*1px进行占位，把真正的路径存在元素的“data-url”（这个名字起个自己认识好记的就行）属性里，只有图片出现在浏览器的可视区域内时再请求加载。

页面加载速度快，减轻服务器压力，节省流量，提升用户体验

1. 使用setTimeOut或setInterval进行加载延迟.

2. 第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。

3. 第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。

1).首先，不要将图片地址放到src属性中，而是放到其它属性(data-original)中。

2).页面加载完成后，根据scrollTop判断图片是否在用户的视野内，如果在，则将data-original属性中的值取出存放到src属性中。

3).在滚动事件中重复判断图片是否进入视野，如果进入，则将data-original属性中的值取出存放到src属性中。

- 为什么传统上利用多个域名来提供网站资源会更有效？
- 浏览器同一时间能够从一个域名下载多少资源

老版本的浏览器2个，新的8个
- 请说出三种减少页面加载时间的方法
(加载时间指感知的时间或者实际加载时间)
1. 脚本在标记中的位置对页面的初次加载时间也有很大影响。位于< head>中的脚本会导致浏览器无法并行加载其他文件（如图像或其他脚本）。一般来说，根据HTTP规范，浏览器每次从同一个域名中最多能同时下载2个文件，而在下载脚本期间，浏览器不会下载其他任何文件，所有其他资源都要等脚本加载完成后才能下载。
把< script>标签都放到文档的末尾，< /body>之前，就可以让页面变得更快。
2. 压缩脚本。把脚本文件中不必要的字节，如空格和注释统统删除。有的精简程序甚至会重写你的部分代码，使用更短的变量名，从而减少整体文件的大小。

- 性能优化为什么要减少 HTTP 访问次数？
- 图像优化
- 关键渲染路径；

1. 减少dom操作

在Javascript各方面中，DOM无疑是最慢的一部分，DOM操作与交互要消耗大量时间，因为它们往往要重新渲染整个页面或者某一部分。
（1）最小化现场更新
一旦你要访问的DOM部分是已经显示的页面的一部分，那就是在进行一个现场更新（因为需要立即对页面对用户的显示进行更新），每一个更改，不管是插入还是移除，都有一个性能惩罚，因为浏览器要重新计算无数尺寸以进行更新。完成一个操作所需的现场更新越多，代码完成执行所花的时间就越长。
要减少现场更新的数量：1）将元素从页面上移除，然后更新，最后再插回原来的位置（不理想，每次页面更新会不必要的闪烁），2）使用文档片段来构建DOM结构，接着将其添加到元素中，`var fragmenr = document.createDocumentFragment();fragment.appendChild(item); list.appendChild(fragment)`，这种方式避免了现场更新和页面闪烁问题。
（2）使用innerHTML
有两种在页面上创建DOM节点的方式：1）createElement()或appendChild()，2）使用innerHTML。对小的DOM更改，效率都差不多；对大的DOM更改，使用innerHTML会比第一种快很多。
当把innerHTML设置为某个值时，后台会调用HTML解析器，然后使用内部DOM调用来创建DOM结构，而非基于Javascript的DOM调用。由于内部方法是编译好的而非解释执行的，所以执行快得多。
调用innerHTML实际上就是一次现场更新，所以使用innerHTML的关键也在于最小化调用它的次数。
（3）使用事件代理
页面上的事件处理程序的数量和页面响应用户交互的速度之间是负相关的关系。所以最好使用事件代理。
（4）注意HTMLCollection
HTMLCollection对Web应用的性能是巨大的损害。任何时候要访问HTMLCollection，不管是属性还是方法，都是在文档上进行一个查询，这个查询开销很昂贵。最小化访问HTMLCollection的次数可以极大地改进脚本的性能。
优化HTMLCollection的访问最重要的地方就是循环。要避免在循环体内多次调用HTMLCollection。
要最小化对HTMLCollection的访问，以下情况返回HTMLCollection对象：
- 进行了getElementsByTagName()的调用
- 获取了元素的childNodes属性
- 获取了元素的attributes属性
- 访问了特殊的集合，如document.images等

2. 部署前，图片压缩，代码压缩
压缩器一般进行如下一些步骤：
- 删除额外的空白（包括换行）
- 删除所有注释
- 缩短变量名
3. 优化js代码结构，减少冗余代码
4. 减少http请求，合理设置 HTTP缓存
5. 使用cdn(内容分发网络)加速

为了让用户尽可能快地加载到页面。对于库来说，如果有很多站点要使用同一个库，最好是把这个库托管到一个公共服务器上，以便所有站点共享和访问。这样，当用户从一个站点跳到另一个站点时，他们就不用再重复下载相同的文件了。
内容分发网络（CDN）可以解决分布共享库的问题。CDN就是一个由服务器构成的网络，这个网络的用途是分散存储一些公共的内容。CDN的每台服务器都包含库的一份副本，分布在世界上不同的国家和地区，以便达到利用带宽和加快下载的目的。
浏览器访问库的时候使用的是一个公共的URL，而CDN的底层则通过地理位置最近、速度最快的服务器提供相应的文件，从而解决了整个系统中的瓶颈问题。
使用CDN中托管的库与使用其他Javascript文件一样，script的src为库的URL。
如果觉得仅仅依赖CDN不保险，可以再提供一个后备< script>标签，以便在CDN不可用时从本地服务器下载相应文件。先检测相应对象是否存在，如果不存在就添加加载本地文件的script标签。

6. 静态资源缓存
- 在制作一个网页应用或网站的过程中，你是如何考虑其 UI、安全性、高性能、SEO、可维护性以及技术因素的？
- 单页面应用有什么SEO方案？
- 你能描述一下你最近使用的一些SEO最佳实践或技巧吗？
- 单页面应用首屏显示比较慢，原因是什么？有什么解决方案？
- 在构建新网站或维护网站时，您能解释一下你用的一些用于提高性能的技术吗？
- 假若你有 5 个不同的样式文件 (stylesheets), 整合进网站的最好方式是?

**合并和放置脚本**
包含脚本的最佳方式是使用外部文件，这样外部文件与标记能清晰地分离开，而且浏览器也能对站点中的多个页面重用缓存过的相同脚本。

推荐将多个脚本文件合并到一个脚本文件中，这样可以减少加载页面时发送的请求数量，而减少请求数量通常都是在性能优化时首先要考虑的。

- 你会用什么方式来增强网站的页面滚动效能？
- 你会用什么工具来查找代码中的性能问题？

- 前端渲染(客户端渲染CSR)和后端渲染（服务器端渲染SSR）的优缺点，SSR和CSR混合怎么处理

- 一个静态资源要上线，里面有各种资源依赖，你如何平稳上线
- 如果要你去实现一个前端模板引擎，你会怎么做

- 你能描述渐进增强 (progressive enhancement) 和优雅降级 (graceful degradation) 之间的不同吗?

**渐进增强** —— 用一些额外的信息层去包裹原始数据。按照‘渐进增强’原则创建出的网页几乎都符合“平稳退化”原则。

**平稳退化** —— 让访问者在他们的浏览器不支持Javascript的情况下，仍能顺利访问你的网站。即使某些功能无法使用，但最基本的操作仍能顺利完成。

性能问题可以分为多个方面，最重要的几点：
- 页面加载性能（最重要）
1. 一般以用户平均加载时间作为指标
浏览器的大致工作过程：
从域名到IP地址，需要DNS查询
HTTP协议用TCP传输，有TCP建立连接过程
如果用HTTPS，还有HTTPS交换证书
网页有图片等请求

网页加载时间，和体积，和请求数都有关。

技术方案划分：
- 缓存：客户端控制的强缓存策略
- 降低请求成本：HTTP DNS，由客户端控制，隔一段时间主动请求DNS获取域名IP，不连系统的DNS
            TCP/TLS连接复用，由服务端升级到HTTP2,尽量合并域名
- 减少请求数：JS,CSS打包到HTML
             用JS控制图片异步加载和懒加载
             小型图片用data-uri
- 减少传输体积：尽量使用SVG/gradient等代替图片
              根据机型和网络状况控制图片清晰度
              对低清晰度图片使用锐化来提升体验
              设计上避免大型背景图

如何做线上监控：
- 数据采集
 Performance API，浏览器记录的性能数据
- 数据展现

- 动画与操作性能
- 内存、电量消耗

工具体系的设计：
前端开发大约要做的事情：
1. 初始化项目
2. 运行和调试
3. 测试
4. 发布

webpack，要保证团队使用的工具版本一致，在项目初始化模板中定义npm script并且在 npm dev-dependency 中规定它的版本号。

调试/构建次数，构建平均时长评估构建效率，对webpack进行优化

1. 使用fragment
```javascript
var fragment = document.createDocumentFragment();

var element = document.createElement('div')
for(let i=0;i<100;i++>) {
  element.appendChild(document.createTextNode(''+i))
  fragment.appendChild(element)
}

document.body.appendChild(fragment)
```
2. 使用innerHTML
```javascript
var element = document.createElement('div')
var array = []
for(let i=0;i<100;i++) {
    array.push('<div>'+i+'</div');
}
element.innerHTML = array.join('')
document.body.appendChild(element)
```

## 渲染长列表
ajax获取数据，数据存入本地数组，数组中每条数据对应插入一个HTML模板片段中，将HTML片段append到节点中。

非完整渲染长列表：
  - 懒加载：无限滚动的，每次只渲染一部分，等其余部分滚动到可见区域，就再渲染另一部分
  - 可视区域渲染：只渲染可见部分，不可见部分不渲染

1. 懒渲染

即无限滚动，在滚动到页面底部时，再去加载剩余的数据。前后端共同优化，后端一次加载比较少的数据可以节省流量，前端首次渲染更少的数据速度会更快。

实现思路：监听父元素的scroll事件

element.scrollTop 元素滚动条内的顶部隐藏部分的高度，元素的内容顶部（卷起来的）到它的视口可见内容（的顶部）的距离。当一个元素内容没有产生垂直方向的滚动条，则scrollTop值为0.
element.scrollHeight，是元素内容高度，包括由于溢出导致的视图中不可见内容。

判断元素是否滚动到底：

`element.scrollHeight - element.scrollTop === element.clientHeight`

```javascript
window.onscroll = () => {
    const maxScrollTop = Math.max(document.body.scrollHeight,document.documentElement.scrollHeight)
    const currentScrollTop = Math.max(document.documentElement.scrollTop,document.documentElement.scrollTop)

    if(maxScrollTop - currentScrollTop < 20) {...}
}

```
2. 可视区域渲染/虚拟列表
只渲染可视区域的列表项，非可见区域的完全不渲染，在滚动条滚动时动态更新列表项。 根据滚动来控制可视区域渲染的列表。
要求：
- 每个数据的展现形式的高度需要一致（最小高度要确定）
- 产品设计上，滚动条需要挂载在一个固定高度的区域
- 一次加载的数据量比较大（1000条以上）

思路：根据可见的高度以及滚动的距离渲染相应的节点。
```javascript
<div @scroll ="handleScroll"> </div>
handleScroll(e) {
    var scrollTop = e.target.scrollTop
    this.updateVisibleData(scrollTop)
},
updateVisibleData(scrollTop=0) {
    const start = Math.floor(scrollTop/itemHeight)
    const end = start + visibleCount
    const visibleData = allData.slice(start,end)
    this.offset = start*itemHeight // translateY偏移量
}

transform: translateY(`${offset}px`)

```