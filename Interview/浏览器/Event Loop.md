
## 浏览器的进程
浏览器是多进程的，主要包括以下进程：
- Browser进程：浏览器的主进程，唯一，负责创建和销毁其它进程，网络资源的下载与管理，浏览器界面的展示、前进后退等
- GPU进程：用于3D绘制等，最多一个
- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
- **浏览器渲染进程（浏览器内核）**：内部是多线程的，每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。

## 浏览器渲染进程（浏览器内核）
浏览器渲染进程是多线程的，页面的渲染，Javascript的执行，事件循环，都在这个进程内进行：
- GUI渲染线程：负责渲染浏览器界面，当界面需要重绘（repaint）或由于某种操作引发回流（reflow）时，该线程就会执行
- Javascript引擎线程：也称为Javascript内核，负责处理JS脚本程序，解析JS脚本，运行代码等（如V8引擎）
- 事件触发线程：用来控制浏览器事件循环（不归JS引擎管），事件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
- 定时器触发线程：setInterval和setTimeout所在线程。W3C在HTML标准中规定，要求setTimeout中低于4ms的时间间隔算为4ms
- 异步HTTP请求线程：在XMLHttpRequest连接后，通过浏览器新开一个线程请求，将监测到状态变更时，如果有回调，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由JS引擎执行。

GUI渲染线程与Javascript引擎线程是互斥的。JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中，等到JS引擎空闲时立即被执行。所以如果JS引擎执行时间过长，会造成页面的渲染不连贯，页面渲染加载阻塞。

## 单线程
JS的单线程，是指在JS引擎中负责解释和执行JS代码的线程唯一，同一时间上只能执行一件任务。

### 为什么要引进单线程
因为浏览器要渲染DOM，JS可以修改DOM结构，JS执行时，浏览器DOM渲染停止。

如果不是单线程的，那么可以同时执行多段JS，如果这多段JS都修改DOM，会出现DOM冲突。（Web Worker会执行多线程，但web worker不能访问window对象，document对象）

**原因：避免DOM渲染的冲突**，当然，可以引入“锁”的机制来解决这些冲突，但大大提高了复杂性，所以JS从诞生开始就选择来单线程。

优点：实现比较简单，执行环境相对单纯

### 单线程的问题
缺点：单线程意味着所有的任务需要排队，前一个执行结束，才会执行后一个任务，如果一个任务耗时过长，后一个任务就不得不一直等着，会拖延整个程序的执行。常见的浏览器无响应，往往因为某段代码长时间运行，导致页面卡死。

为了解决这个问题，JS将任务的执行模式分为两种：同步和异步。采用异步编程的原因：

- JS是单线程
- 提供CPU的利用率

## 同步 & 异步
### 异步过程
主线程发起一个异步操作，相应的工作线程接受请求并告知主线程已收到（异步函数返回），主线程继续执行后面的任务，同时工作线程执行异步任务，工作线程完成异步任务后，通知主线程，主线程收到通知后，执行一定的动作（回调函数）。

工作线程在完成任务后通知主线程是如何实现的？ ==》 消息队列和事件循环。

## 消息队列 & 事件循环
工作线程将消息放在消息队列，主线程通过事件循环过程去取消息。

- 消息队列：先进先出的队列，里面存放各种消息
- 事件循环：指主线程重复从消息队列中取消息、执行的过程，这种机制叫事件循环机制。取一次消息并执行的过程叫一次循环。

事件循环是JS实现异步的具体解决方案。其中同步代码直接执行，异步函数先放在异步队列中，等同步函数执行完毕后，轮询执行异步队列的回调函数。

### 消息队列
消息就是注册异步任务时添加的回调函数。

主线程执行完当前循环中的所有代码后，就会从消息队列中取消息并执行它，至此就完成了工作线程对主线程的通知，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，则工作线程执行完毕后，就没有必要通知主线程，也没有必要往消息队列放消息。异步函数的回调函数，一定不在当前这轮事件循环中执行。

消息队列中的每条消息实际上都对应一个事件。其中一个重要的异步过程就是DOM事件，如addEventListener，就是异步过程的发起函数，事件监听器函数就是异步的回调函数。事件触发时，表示异步任务完成，会将事件监听器封装成一条消息放在消息队列中，等待主线程执行。事件机制实际上就是异步过程的通知机制。


- Q：JS执行过程中分为哪些阶段,异步整个执行周期
- Q：JS为什么要区分微任务和宏任务，介绍宏任务和微任务

浏览器为我们提供了JS引擎不具备的特性 Web API，包括DOM API，定时器，HTTP请求等特性，可以帮我们实现异步，非阻塞的行为。

当我们调用函数时，函数会被放入调用栈（也叫执行上下文栈），调用栈是JS引擎的一部分，并非浏览器特有的，是个栈数据结构，后进先出，当函数执行完毕返回时，会被弹出跳用栈

事件循环的工作就是连接任务队列和调用栈，当调用栈中的任务均执行完毕出栈，调用栈为空时，事件循环会检查队列中是否存在等待执行的任务，如果有，取出队列中第一个任务，放入调用栈。执行完毕，返回其返回值，被弹出调用栈。

2. Event Loop

事件循环本质上是user agent（如浏览器端）用于协调用户交互（鼠标，键盘），脚本（如JS），渲染（如HTML DOM、CSS样式），网络等行为的一个机制。是嵌入 JavaScript 的 user agent 需要通过事件循环来与多种事件源交互，协调各类事件的机制。

各种浏览器事件同时触发时，会有先来后到的排队问题，决定这些事件如何排队触发的机制，就是事件循环。从开发者角度看，主要有两个队列：

- JS外部的队列。主要是浏览器协调的各类事件的队列，即 Task Queue
- JS内部的队列，主要是JS内部执行的任务队列，即 Microtask Queue

这些队列并不是先进先出的，排在最前面但是没有满足条件的也是不会执行的。（如setTimeout）

**外部队列**包括：
- DOM操作（页面渲染）
- 用户交互（鼠标，键盘）
- 网络请求（Ajax等）
- History API操作
- 定时器等（setTimeout等）
HTML标准中明确指出一个事件循环可以由一个或多个外部队列，而每个外部事件源都有一个对应的外部队列。不同事件源的队列可以有不同的优先级（如网络事件和用户交互之间，浏览器可以优先处理鼠标行为，从而让用户感觉更流畅）

**内部队列**包括：
HTML标准没有明确规定这个队列的事件源，通常认为有以下几种：
- Promise的成功（then）和失败（catch）
- MutationObserver

**处理模型**
1. 从外部队列中取出一个可执行任务，有则执行，没有则下一步
2. 挨个取出内部队列中的所有任务执行，执行完毕或没有就下一步
3. 浏览器渲染

轮到内部队列执行的时候，一定会先全部执行完内部队列才会继续往下走去执行外部队列的任务

JS 执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤：
（1）所有同步任务都在主线程上执行，形成一个执行栈。
（2）主线程之外，还存在一个"任务队列"。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
（4）主线程不断重复上面的第三步。
event loop 基本每次都会被问到，一般就是说微任务、宏任务，怎么样的运行过程，以上是比较书面一点的回答，我自己也没记得。

- 事件循环
理解浏览器是如何处理用户输入、Web 请求和一般事件的。知道如何识别并正确实现异步代码。
js 单线程、
调用栈 (call stack) 和任务队列 (task queue) 的区别,宏任务与微任务的执行顺序
async，setTimeout和promise的执行顺序
Process.nextTick，setImmediate 和promise.then的优先级
理解 JavaScript 中异步和单线程分别是怎样的

宏任务、微任务、UI渲染等的执行顺序，浏览器端的必须要掌握，node端的有精力的最好也能掌握。

- 解释同步 (synchronous) 和异步 (asynchronous) 函数的区别。

　JS的解析是由浏览器中的JS解析引擎完成的，比如谷歌的是V8。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。

　　JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。

- “同步模式”：程序的执行顺序与任务的排列顺序是一致的、同步的；

- "异步模式"：每一个任务有一个或多个回调函数（callback），前一个任务结束后会执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。

- JS线程
执行：JS引擎线程
协助：事件触发线程，定时器触发线程，HTTP异步请求线程

JS引擎线程是真正执行的，其他是协助。

- JS引擎线程：也叫JS内核，负责解析执行JS脚本程序的主线程，如V8引擎
- 事件触发线程：属于浏览器内核线程，主要用于控制事件，如鼠标，键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待JS引擎线程执行
- 定时器触发线程：主要控制setInterval和setTimeout，用来计时，计时完毕后，把定时器的处理函数推进事件队列中，等待JS引擎线程执行
- HTTP异步请求线程：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的回调函数推进事件队列中，等待JS引擎线程执行。

**浏览器对同一域名的并发连接数是有限的，通常为6个**
在事件循环内部，实际上有2种类型的队列：宏任务macro队列（或只叫做任务队列），用于宏任务；微任务队列，用于微任务

- **宏任务**
分为：
  - 同步任务：按顺序执行，前一个任务完成后，才能执行后一个任务
  - 异步任务： 不直接执行，只有满足触发条件时，相关线程才将该异步任务推进任务队列中，等到JS引擎主线程上的任务执行完毕时才开始执行，如DOM事件，setTimeout，异步Ajax等

常用的：setTimeout，setInterval，setImmediate

- **微任务**
微任务是ES6和Node环境下，主要API有：Promise，process.nextTick

微任务的执行在宏任务的同步任务之后，在异步任务之前。

常用的：Promise callback，process.nextTic，queueMicrotask

Promise属于微任务，当一个Promise解决（resolve）并且调用它的then,catch或finally方法时，这些方法里的回调被添加到微任务队列，这意味着then,catch或finally方法内回调函数不是立即被执行，本质上是为Javascript代码添加了一些异步行为。

事件循环给予任务不同的优先级：
- 当前在调用栈（call stack）内的所有函数会被执行。当它们返回值的时候，会被从栈内弹出
- 当调用栈是空时，所有排队的微任务会一个接一个从微任务队列中弹出进入调用栈中，然后在调用栈中被执行（微任务也能返回一个新的微任务，有效的创建无限的微任务循环。
- （如果调用栈和微任务队列都是空的）一旦微任务队列中所有的任务被放入调用栈并且最终被弹出，事件循环会检查宏任务队列里是否还有任务，如果有，就从宏任务队列中弹出进入调用栈，被执行后从调用栈中弹出。


```javascript
console.log('start') //1. console.log加入到调用栈中，控制台输出，从调用栈弹出
setTimeout(() => {console.log('timeout')}, 0) // 2. setTimeout弹入到调用栈中，它的回调函数被添加到Web API，直到计时器完成计时。即使时间为0，在它被添加到宏任务队列之后，回调还是会被首先推入Web API
Promise.resolve('Promise').then(res => console.log(res)) // 3. Promise.resolve被添加到调用栈，在resolve之后，它的then中的回调函数被添加到微任务队列
console.log('end') // 4. console.log加入到调用栈中，控制台输出，从调用栈弹出

// 5. 此时调用栈为空，去检查微任务队列中是否有在排队的任务。此时Promise的then的回调正在微任务队列中，弹入调用栈，控制台输出，从调用栈弹出
// 6. 调用栈和微任务队列都为空，检查宏任务队列，setTimeout的回调正在宏任务队列中，被弹入调用栈，回调函数返回console.log，控制台输出，从调用栈弹出
```
打印顺序：
start
end
Promise
timeout

Async/Await的情况：
```javascript
const one = Promise.resolve('one')
async function myFunc () {
  console.log('in function')  // 1. 打印第一行'in function'
  const res = await one() // 2. 遇到await关键字，函数one被弹入调用栈，并返回一个resolved的promise。
  console.log(res)
}

console.log('before function')
myFunc() // 调用函数
console.log('after function')
```
打印顺序：
before function
in function
after function
one

await关键字会使异步函数在执行promise的时候被暂停，之后的内容在promise被resolve后，在then方法的onFulfilled函数（then的第一个参数，回调函数）执行时继续执行，所以async函数中剩余的代码会在微任务中运行，而不是一个常规任务。

遇到await时，异步函数myFunc被暂停，JS引擎跳出异步函数，并在异步函数被调用的执行上下文中继续执行代码。等调用的执行上下文中没有更多任务时，去检查微任务队列，在resolve了one的值以后，异步函数myFunc开始排队，myFunc被弹出调用栈中，在它之前中断的地方继续运行。

区别：使用Promise的then方法的话，promise的主体将会被继续执行。而await关键字则暂停了async函数。

- 请说出下面代码的执行顺序

```javascript
async function async1() {
  console.log(1);
  const result = await async2();
  console.log(3);
}
async function async2() {
  console.log(2);
}

Promise.resolve().then(() => {
  console.log(4);
});

setTimeout(() => {
  console.log(5);
});

async1();

console.log(6);
```

解答：[1,2,6,4,3,5]。这道题目主要考对 JS 宏任务和微任务的理解程度，JS 的事件循环中每个宏任务称为一个 Tick(标记)，在每个标记的末尾会追加一个微任务队列，一个宏任务执行完后会执行所有的微任务，直到队列清空。上题中我觉得稍微复杂点的在于 async1 函数，async1 函数本身会返回一个 Promise，同时 await 后面紧跟着 async2 函数返回的 Promise， console.log(3)其实是在 async2 函数返回的 Promise 的 then 语句中执行的，then 语句本身也会返回一个 Promise 然后追加到微任务队列中，所以在微任务队列中 console.log(3)在 console.log(4)后面，

第 10 题：（头条）异步笔试题

```javascript
// 写出以下代码的运行结果
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}
async function async2() {
  console.log("async2");
}
console.log("script start");
setTimeout(function () {
  console.log("setTimeout");
}, 0);
async1();
new Promise(function (resolve) {
  console.log("promise1");
  resolve();
}).then(function () {
  console.log("promise2");
});
console.log("script end");
```

Node与浏览器 EventLoop的差异

