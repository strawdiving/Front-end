## 算法
最长子序列
无重复字符的最长子串（leetcode #3)
// "abcabcbb" abc // "pwwkew" wke
```javascript
var lengthOfLongestSubstring = function(s) {
  if (s.length <= 1) return s.length
  let longest = 0
  let longestS = s[0]
  for (let index = 1; index < s.length; index++) {
    const cur = s[index]

    const hasRepeat = longestS.indexOf(cur)
    if (hasRepeat >= 0) {
      longest = Math.max(longest, longestS.length)
      longestS = (longestS + cur).slice(hasRepeat + 1)
    } else {
      longestS += cur
    }
  }
  return Math.max(longest, longestS.length)
}

```

设计一套机制，两个千位大数相乘
- 大数相加
两个非常大的数字（已经超过Number范围）的加法运算
```javascript
function bigNumberSum(a, b) {
  // 123456789
  // 000009876

  // padding
  let cur = 0
  while (cur < a.length || cur < b.length) {
    if (!a[cur]) {
      a = '0' + a
    } else if (!b[cur]) {
      b = '0' + b
    }
    cur++
  }

  let curried = 0
  const res = []

  for (let i = a.length - 1; i > -1; i--) {
    const sum = curried + +a[i] + +b[i]
    if (sum > 9) {
      curried = 1
    } else {
      curried = 0
    }
    res[i] = sum % 10
  }
  if (curried === 1) {
    res.unshift(1)
  }

  return res.join('')
}

```

做一个数组的压缩
数组的展平flatten
```javascript
function flatten(arr) {
	let temp = []
	for(leti=0;i<arr.length;i++) {
		if(Array.isArray(arr[i])) {
			const t = flatten(arr[i])
			temp= [...temp,...t]
		} else {
			temp.push(arr[i])
		}
	}
	return temp
}
```

```javascript
arr.prototype.flat = function() {
	this.toString().split(',')
	.map(item=>item)
}
```
原理： [1, 2, [3, 4, [5, 6]]].toString() "1,2,3,4,5,6"

实现一个栈，具有push和pop方法，还有获取他的最小值，复杂度是O(1) 实现如下:

rightView（leetcode 原题）， 层序遍历，取每一层最右边元素。

剑指offer：
1. 合并两个有序列表
2. 合并多个有序链表
3. 输出链表倒数第K个数
- 从排好序的两个链表中，找到相同的节点，并输出链表

5. 数组最大K个数，可考虑海量数据场景，分治，合并，大小顶堆
https://www.zhihu.com/question/28874340

6. 二维数组查找
- 给定一个不含重复数字的数组arr,指定个数n,目标和sum,判断是否含有由n个不同数字相加得到sum的情况（leetcode 40 变种， 数字不得重复使用）
- 有一个数组和一个值，需要求大于等于该值的最小长度。如[2,3,4,7]和5,最小是1，因为7大于5；如果数字是8，则最小是2，因为4+7>8
排序+滑动窗口
- 求有序数组中小于某个数的个数，如【1，2，3，4】，2 => 1
用二分查找
- 指定数组 找出 数字之和为 n 的组合（剑指offer） 
Arr [1 , 2 , 3 , 4].   n 5  Return [1, 4]

// 返回数字之和为n的数的下标
```javascript
var twoSum = function(nums,target) {
	// key: num ,value: index
	const numsMap = {}
	for(let i=0;i<nums.length;i++) {
		const cur = nums[i]
		if(numsMap[cur]!== undefined) {
			return [numsMap[cur],i]
		}
		else {
			const rest = target - cur
			numsMap[rest] = i
		}
	}
}
```


有一个无序数组求中位数
在从左向右和从上往下皆为升序的二维数组中，查找一个数是否存在，存在的话输出它的位置


7. 反转链表
8. 从尾到头打印链表
在O(1)时间内删除链表节点
删除链表的重复节点
用数组实现一个栈，考虑数组扩容的问题

1. 堆排序，快速排序，冒泡排序
2. dfs,bfs
3. 二分查找
```javascript
const binarySearch = function(arr,target) {
	let start = 0
	let end = arr.length-1

	while(start<=end) {
		const mid = Math.floor((start+end)/2)
		const cur = arr[mid]

		if(cur === target) return mid
		if(cur<target) {
			start = mid+1
		} else {
			end = mid-1
		}
	}
	return false
}

```
4. 二叉树的前中后序遍历
5. 非递归写法二叉树查找K的位置
6. 二叉树深度，二叉树广度
7. 判断是否平衡二叉树
二叉树是否存在某个路径的和等于一个值
二叉树路径总和（leetcode 112）
二叉树深度为n的遍历，遍历有哪几种方式
二叉树搜寻算法

如何在很大数量级的数据中筛选出前10万个最大值  https://www.zhihu.com/question/28874340

判定一定范围内有多少质数（leetcode #204)
```javascript
function countPrimes(k) {
	let count=0
	const hashMaps={}
	for(let i=2;i<k;i++) {
		if(!hashMap[i]) {
            count++
			for(let j=2;i*j<k;j++) {
				hash[i*j] = true
			}
		}
	}
	return count
}
```
优化：
```javascript
var countPrimes = function(n) {
  const arr = new Array(n + 1).fill(true)
  let count = 0

  for (let i = 2; i < n; i++) {
    if (arr[i]) {
      // 如果i是质数
      for (let j = i + i; j < n; j = j + i) {
        arr[j] = false // i的n倍数肯定不是质数
      }
      count++
    }
  }
  return count
}

```
有效的括号数（leetcode #20)
input: (){}[],output:true
input: ([,output:false
```javascript
var isValid = function(s) {
  const hashMap = {
    ']': '[',
    '}': '{',
    ')': '('
  }

  const stacks = []

  for (let i = 0; i < s.length; i++) {
    const cur = s[i]
    if (!hashMap[cur]) {
      stacks.push(cur)
    } else {
      const pop = stacks.pop()
      if (pop !== hashMap[cur]) {
        return false
      }
    }
  }

  return stacks.length === 0
}

```

## 代码实现
如何批量抓取文章

屏幕占满和未占满的情况下，使footer固定在底部，尽量多种方法。
5.获取页面所有img并且下载 
3. 根据条件获取递归树中过的某一节点
5. 实现 当 ul 点击时 输出 子元素 li 的内容、
点击table的td显示td内容
6.两个同源tab之间的交互，数据同步
6.改写一段代码，不考虑随机延时的影响，按顺序输出一段数字
代码实现连续点击3次每次间隔不超过1秒然后弹出页面（类似安卓的关于手机彩蛋）；
给有数组对象添加一个方法，返回出现频率>=n的元素列表；
7. [1,2,3].map(parseInt) 执行结果
1、实现sum(1)(2)(3).valueOf()，实现这么一个sum函数，返回6
3. 实现（10）.add(10).add(10) 函数柯里化？
2.taskSum(1000,()=>{console.log(1)}).task(1200,()=>{console.log(2)}).task(1300,()=>{console.log(3)})，这里等待1s，打印1，之后等待1.2s，打印2，之后打印1.3s，打印3
10. versions是一个项目的版本号列表，因多人维护，不规则
var versions=['1.45.0','1.5','6','3.3.3.3.3.3.3']
要求从小到大排序，注意'1.45'比'1.5'大
sorted=['1.5','1.45.0','3.3.3.3.3.3','6'] 
1.	给一个由域名组成的字符串进行按子域名分组的反转，比如 news.toutiao.com 反转成 com.toutiao.news
2.	153812.7  转化153,812.7；千位加逗号；数字千分位处理，正则和非正则都要实现
1、多空格字符串格式化为数组
日期转化为2小时前，1分钟前等、固定日期与当前时间格式化处理；输入一个日期 返回几秒前 几天前或者几月前；
换行字符串格式化
实现一个方法，参数是一个generator函数，执行结果是执行完所有generator中的yield
写一个url解析函数，包括hash
1. function request(urls, maxNumber, callback) 要求编写函数实现，可以批量请求数据，所有的 URL 地址在 urls 参数中，根据urls数组内的url地址进行并发网络请求，最大并发数maxNumber,当所有请求完毕后调用callback函数(已知请求网络的方法可以使用fetch api)
1. 写一个eventBus
2. 如何对请求进行缓存，例如有10个异步请求，如果有一个异步请求返回结果，剩下的请求就用这个结果，并且能够传入成功和失败的回调函数

用Promise.race 再外面自己封装一层

6. js多线程如何共享大的数据
4. 状态管理 
5. 图像算法 
7. 长列表渲染

如何保证一次只能并发10个任务~（用JavaScript实现指定数量的并发限制）

```javascript
let arr = [1, 2, 3];
let fnArray = [];
for (var i = 0; i < arr.length; i++) {
    fnArray[i] = function () {
        return arr[i] * 2;
    }
}
let result = fnArray.find((fn) => {
    return fn() === 4;
})
console.log(result);

```
实现一个deepClone需要兼容set、map、symbol、object
如何实现点击元素外部关闭元素

输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。(leetCode 相似题 #7) ，要考虑边界情况，如正负数，最后一位0
```javascript
function reverseInt(number) {
	if(isInt(number)) { throw new Error('number must be an int')}
	if(number === 0) {return 0}

	const flag = number<0? '-':''
	let num = Math.abs(number)

	while(num%10 === 0) {
		num = num/10
	}

	let result = ''
	while(num >=10) {
		const temp = num%10
		result +=temp
		num = parseInt(num/10)
	}
	return flag+result+num
}
```



