
# Web性能

## 雅虎军规——如何让页面加载更快
- 浏览器同一时间能够从一个域名下载多少资源
老版本的浏览器2个，新的8个
- 性能优化为什么要减少 HTTP 访问次数？
- 关键渲染路径；

1. 最小化HTTP请求
大多数页面的加载时间都是在下载图片，样式，脚本等。减少组件数量从而减少请求数量，是页面加载更快的关键
- 合并文件，将多个脚本文件合并到一个脚本文件中，通过合并js,css文件来减少加载页面时HTTP请求的数量
- CSS Sprites，CSS精灵，减少图片请求数量，通过将背景图合并为单个图像，通过设置background-image,background- repeat和background-position属性来进行背景定位,显示部分需要的图像

好处：CSS Sprites能减少图片的字节,减少网页的http请求，提高页面的性能；
不足：维护成本高，一改就要改整张
     加载速度优势在http2多路复用后没有了
- 内联图像，使用如data:url语法，将图像转为base64语法嵌入实际页面中

2. 减少DNS查找
输入域名时，浏览器经过DNS解析返回服务器的IP地址，DNS解析需要成本，通常要20-120ms才能解析成功。
- 通过缓存DNS查找，DNS保存在操作系统的DNS缓存中
- 要减少唯一主机名。DNS缓存为空时，DNS查找的数量等于网页中唯一主机名的数量，减少后可能减少页面中发生的并行下载量，准则是将组件分成至少2个但不超过4个主机名。减少DNS查找和允许高并行下载的良好折中。

3. 避免重定向
重定向会降低用户体验。在用户和HTML文档间插入重定向会延迟页面中的所有内容，页面中任何内容都无法呈现。
使用301和302状态码完成重定向，浏览器自动将用户带到Location字段指定的URL。跳转所需的信息都在HTTP头，响应的主体通常是空的。

4. 使Ajax可缓存
使响应可缓存，合理设置 HTTP缓存，减少http请求。除了添加Expires或Cache-Control头，还有gzip组件，压缩JS等。

5. 延迟加载组件
看最初页面的渲染需要什么，其他内容可以延迟加载，包括页面渲染之后才执行的动画，拖放的JS代码，不在首屏显示的图像，组件等。
懒加载，延迟加载甚至不加载，对服务器前端有一定的缓解压力作用

- 按需加载，不同页面的元素判断标准
- 延迟加载和捆绑拆分；

6. 预加载组件
预加载就是将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。
在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。预加载是提前加载，会对服务器前端有一定压力。

图片预先加载到浏览器中，访问者可享受到极快的加载速度。这对图片画廊及图片占据很大比例的网站来说十分有利，它保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时获得更好的用户体验。

7. 减少DOM数量，最小化DOM访问
DOM数量多，JS访问（如查找等操作）DOM的速度慢。
- 减少dom操作
在Javascript各方面中，DOM无疑是最慢的一部分，DOM操作与交互要消耗大量时间，因为它们往往要重新渲染整个页面或者某一部分。

缓存访问过的元素的引用；

（1）最小化现场更新——在DOM树外更新节点，再添加到DOM树
一旦你要访问的DOM部分是已经显示的页面的一部分，那就是在进行一个现场更新（因为需要立即对页面对用户的显示进行更新），每一个更改，不管是插入还是移除，浏览器都要重新计算无数尺寸以进行更新。完成一个操作所需的现场更新越多，代码完成执行所花的时间就越长。

1）使用文档片段来构建DOM结构，接着将其添加到元素中，`var fragmenr = document.createDocumentFragment();fragment.appendChild(item); list.appendChild(fragment)`，这种方式避免了现场更新和页面闪烁问题。
2）使用innerHTML
有两种在页面上创建DOM节点的方式：常规createElement或appendChild，对小的DOM更改效率差不多；大的DOM更改，innerHTML快很多。

当把innerHTML设置为某个值时，后台会调用HTML解析器，然后使用内部DOM调用来创建DOM结构，而非基于Javascript的DOM调用。由于内部方法是编译好的而非解释执行的，所以执行快得多。

调用innerHTML实际上就是一次现场更新，所以使用innerHTML的关键也在于最小化调用它的次数。
（3）使用事件代理
页面上的事件处理程序的数量和页面响应用户交互的速度之间是负相关的关系。所以最好使用事件代理。
（4）注意HTMLCollection
HTMLCollection对Web应用的性能是巨大的损害。任何时候要访问HTMLCollection，都是在文档上进行一个查询，开销很昂贵。最小化访问HTMLCollection的次数可以极大地改进脚本的性能。
最重要的地方就是循环。要避免在循环体内多次调用HTMLCollection。
以下情况返回HTMLCollection对象：
- 进行了getElementsByTagName()的调用
- 获取了元素的childNodes属性
- 获取了元素的attributes属性
- 访问了特殊的集合，如document.images等

1. 使用fragment
```javascript
var fragment = document.createDocumentFragment();

var element = document.createElement('div')
for(let i=0;i<100;i++>) {
  element.appendChild(document.createTextNode(''+i))
  fragment.appendChild(element)
}

document.body.appendChild(fragment)
```
2. 使用innerHTML
```javascript
var element = document.createElement('div')
var array = []
for(let i=0;i<100;i++) {
    array.push('<div>'+i+'</div');
}
element.innerHTML = array.join('')
document.body.appendChild(element)
```

8. 跨域拆分组件
拆分组件达到最大化的并行下载，可以托管HTML和动态内容，将组件拆分到两个域名。考虑DNS查询的副作用，最好保证使用的域名不超过2-4个。

9. 最少的iframe
iframe允许html文档被插入到父文档。
优点：
- 帮助解决缓慢的第三方内容的加载，如广告
- 安全沙盒
- 并行下载脚本

缺点：
- 即使空的也消耗资源
- 阻塞页面的onload
- 非语义化（标签）
10. 不用出现404
HTTP请求昂贵，因此获得无用的响应是没有必要的，会影响用户体验。

11. cdn的原理，cdn选择最近的缓存服务器是怎么实现
使用CDN(内容分发网络)加速
CDN是一群不同地点的服务器，可以更高效地分发内容到用户。在多个地理位置分散的server上部署内容，会使页面加载更快。

为了让用户尽可能快地加载到页面。如果有很多站点要使用同一个库，最好是把这个库托管到一个公共服务器上，以便所有站点共享和访问。这样，当用户从一个站点跳到另一个站点时，他们就不用再重复下载相同的文件了。

内容分发网络（CDN）可以解决分布共享库的问题。CDN就是一个由服务器构成的网络，这个网络的用途是分散存储一些公共的内容。CDN的每台服务器都包含库的一份副本，分布在世界上不同的国家和地区，以便达到利用带宽和加快下载的目的。

浏览器访问库的时候使用的是一个公共的URL（script的src为库的URL），而CDN的底层则通过地理位置最近、速度最快的服务器提供相应的文件，从而解决了整个系统中的瓶颈问题。

为保险，要提供一个后备< script>标签，在CDN不可用时从本地服务器下载相应文件。先检测相应对象是否存在，如果不存在就添加加载本地文件的script标签。

12. 利用HTTP缓存——Cache-Control或Expires头
- 对静态组件，通过Expires头实现永不过期策略
- 动态组件：Cache-Control帮client处理条件请求
对脚本，样式，图像等进行缓存，减少HTTP请求的数量和大小。

配置ETag/If-Non-Match，验证浏览器缓存中的资源和server上资源是否匹配。ETag是资源内容的唯一标识，比Last-Modified更灵活的实体的机制。

13. Gzip组件
请求头Accept-Encoding字段，server看到该字段，就会选取列表中的某个方法压缩响应，server通过Content-Encoding提示客户端。
gzip一般可减小响应的70%，尽可能去gzip更多文本类型的文件，如html，脚本，样式，xml，json等。图片，pdf等本身已被压缩过，不需要gzip。

14. 将CSS放在头部
样式表放在文档底部，妨碍了浏览器的逐步渲染，避免放在后面导致的在页面加载完以后更改样式重绘页面。

15. 将Javascript放在底部
位于< head>中的脚本会导致浏览器无法并行加载其他文件。把< script>标签都放到文档的末尾，< /body>之前
一般浏览器每次从同一个域名中最多能同时下载2个文件，而在下载脚本期间，浏览器不会下载其他任何文件，所有其他资源都要等脚本加载完成后才能下载。
一个替代办法是使用异步脚本，defer在页面加载完以后再执行，async一下载完立即执行

16. 使用外部JS和CSS
包含脚本的最佳方式是使用外部文件，这样外部文件与HTML能清晰地分离，浏览器会缓存JS和CSS文件，站点中的多个页面重用。

17. 压缩JS和CSS
- 删除不必要的字符，如空格，换行和注释。
- 缩短变量名，有的压缩程序会重写你的部分代码，使用更短的变量名，从而减少整体文件的大小。
- 优化js代码结构，减少冗余代码

18. 图片优化
压缩图片
优化CSS精灵图

- 何时预取和预加载资源

实现预加载的几种方法：
- 使用HTML标签，image对象
- 用CSS和JavaScript实现预加载；
- 仅使用JavaScript实现预加载；
- 使用Ajax实现预加载。

常用的是new Image();设置其src来实现预载，再使用onload方法回调预载完成事件。只要浏览器把图片下载到本地，同样的src就会使用缓存，这是最基本也是最实用的预载方法。当Image下载完图片头后，会得到宽和高，因此可以在预载前得到图片的大小(方法是用记时器轮循宽高变化)。

- 如何对音频和视频资源进行预加载
### 图片延迟加载,如何实现图片滚动懒加载
当访问一个页面的时候，想把img元素或是或是其他元素背景图片路径替换成一张大小为的图片的路径（这样只需请求一次俗称占位），才设置图片的真实路径，让图片显示出来，这就是图片懒加载。

如果没有src属性，浏览器就不会发出请求去下载图片，只有通过javascript设置了图片路径，浏览器才会发送请求。

页面加载速度快，减轻服务器压力，节省流量，提升用户体验

1. 使用setTimeOut或setInterval进行加载延迟.

2. 第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。

3. 第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。

 懒加载的原理就是先在页面中把所有的图片统一使用一张占位图1*1px进行占位，把真正的路径存在元素的“data-url”（这个名字起个自己认识好记的就行）属性里，只有图片出现在浏览器的可视区域内时再请求加载。
1).首先，不要将图片地址放到src属性中，而是放到其它属性(data-original)中。

2).页面加载完成后，根据scrollTop判断图片是否在用户的视野内，如果在，则将data-original属性中的值取出存放到src属性中。

3).在滚动事件中重复判断图片是否进入视野，如果进入，则将data-original属性中的值取出存放到src属性中。

部署前，图片压缩，代码压缩
6. 静态资源缓存

- 你能描述渐进增强 (progressive enhancement) 和优雅降级 (graceful degradation) 之间的不同吗?

**渐进增强** —— 用一些额外的信息层去包裹原始数据。按照‘渐进增强’原则创建出的网页几乎都符合“平稳退化”原则。

**平稳退化** —— 让访问者在他们的浏览器不支持Javascript的情况下，仍能顺利访问你的网站。即使某些功能无法使用，但最基本的操作仍能顺利完成。
- 在制作一个网页应用或网站的过程中，你是如何考虑其 UI、安全性、高性能、SEO、可维护性以及技术因素的？
- 单页面应用有什么SEO方案？
- 你能描述一下你最近使用的一些SEO最佳实践或技巧吗？
- 单页面应用首屏显示比较慢，原因是什么？有什么解决方案？
- 在构建新网站或维护网站时，您能解释一下你用的一些用于提高性能的技术吗？
- 假若你有 5 个不同的样式文件 (stylesheets), 整合进网站的最好方式是?
- 你会用什么方式来增强网站的页面滚动效能？
- 你会用什么工具来查找代码中的性能问题？

- 前端渲染(客户端渲染CSR)和后端渲染（服务器端渲染SSR）的优缺点，SSR和CSR混合怎么处理

[Vue SSR 指南](https://ssr.vuejs.org/zh/)

- 一个静态资源要上线，里面有各种资源依赖，你如何平稳上线
- 如果要你去实现一个前端模板引擎，你会怎么做

性能问题可以分为多个方面，最重要的几点：
- 页面加载性能（最重要）
1. 一般以用户平均加载时间作为指标
浏览器的大致工作过程：
从域名到IP地址，需要DNS查询
HTTP协议用TCP传输，有TCP建立连接过程
如果用HTTPS，还有HTTPS交换证书
网页有图片等请求

网页加载时间，和体积，和请求数都有关。

技术方案划分：
- 缓存：客户端控制的强缓存策略
- 降低请求成本：HTTP DNS，由客户端控制，隔一段时间主动请求DNS获取域名IP，不连系统的DNS
            TCP/TLS连接复用，由服务端升级到HTTP2,尽量合并域名
- 减少请求数：JS,CSS打包到HTML
             用JS控制图片异步加载和懒加载
             小型图片用data-uri
- 减少传输体积：尽量使用SVG/gradient等代替图片
              根据机型和网络状况控制图片清晰度
              对低清晰度图片使用锐化来提升体验
              设计上避免大型背景图

如何做线上监控：
- 数据采集
 Performance API，浏览器记录的性能数据
- 数据展现

- 动画与操作性能
- 内存、电量消耗

工具体系的设计：
前端开发大约要做的事情：
1. 初始化项目
2. 运行和调试
3. 测试
4. 发布

webpack，要保证团队使用的工具版本一致，在项目初始化模板中定义npm script并且在 npm dev-dependency 中规定它的版本号。

调试/构建次数，构建平均时长评估构建效率，对webpack进行优化

## 渲染长列表
ajax获取数据，数据存入本地数组，数组中每条数据对应插入一个HTML模板片段中，将HTML片段append到节点中。

非完整渲染长列表：
  - 懒加载：无限滚动的，每次只渲染一部分，等其余部分滚动到可见区域，就再渲染另一部分
  - 可视区域渲染：只渲染可见部分，不可见部分不渲染

1. 懒渲染

即无限滚动，在滚动到页面底部时，再去加载剩余的数据。前后端共同优化，后端一次加载比较少的数据可以节省流量，前端首次渲染更少的数据速度会更快。

实现思路：监听父元素的scroll事件

element.scrollTop 元素滚动条内的顶部隐藏部分的高度，元素的内容顶部（卷起来的）到它的视口可见内容（的顶部）的距离。当一个元素内容没有产生垂直方向的滚动条，则scrollTop值为0.
element.scrollHeight，是元素内容高度，包括由于溢出导致的视图中不可见内容。

判断元素是否滚动到底：

`element.scrollHeight - element.scrollTop === element.clientHeight`

```javascript
window.onscroll = () => {
    const maxScrollTop = Math.max(document.body.scrollHeight,document.documentElement.scrollHeight)
    const currentScrollTop = Math.max(document.documentElement.scrollTop,document.documentElement.scrollTop)

    if(maxScrollTop - currentScrollTop < 20) {...}
}

```
2. 可视区域渲染/虚拟列表
只渲染可视区域的列表项，非可见区域的完全不渲染，在滚动条滚动时动态更新列表项。 根据滚动来控制可视区域渲染的列表。
要求：
- 每个数据的展现形式的高度需要一致（最小高度要确定）
- 产品设计上，滚动条需要挂载在一个固定高度的区域
- 一次加载的数据量比较大（1000条以上）

思路：根据可见的高度以及滚动的距离渲染相应的节点。
```javascript
<div @scroll ="handleScroll"> </div>
handleScroll(e) {
    var scrollTop = e.target.scrollTop
    this.updateVisibleData(scrollTop)
},
updateVisibleData(scrollTop=0) {
    const start = Math.floor(scrollTop/itemHeight)
    const end = start + visibleCount
    const visibleData = allData.slice(start,end)
    this.offset = start*itemHeight // translateY偏移量
}

transform: translateY(`${offset}px`)

```

# 前端工程化webpack性能优化

高性能：CDN部署，缓存控制，缓存复用，请求合并，按需加载，同步/异步加载，HTTP2服务端资源推送，CSS内嵌

组件化开发：规划每个页面的资源加载策略，无论访问哪个页面都能按需加载页面所需资源，没访问过的无需加载，访问过的缓存复用
性能优化的核心：
- 按需加载
- 延迟加载
- 预加载
- 请求合并

前端工程化：
- 前端开发要自成体系，包括构建、部署和运维，不再和后端耦合，后端通过RESTful API提供服务
- 设计要分层，来应对需求和技术的变化

模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。只有这样，才有多人协作的可能

模块的打包和加载问题：1. 用Webpack+Babel将所有模块打包成一个文件同步加载，也可以打成多个chunk异步加载；

前端项目的性能优化：
webpack4，要另外安装独立的webpack-cli命令行工具包
production阶段：
- 开启所有的优化代码
- 更小的bundle大小
- 去除掉只在开发阶段运行的代码
- Scope hoistion和Tree-Shaking
- 自动启用uglifyjs对代码进行压缩


- 按需加载
vue有很多页面，用vue-router配置路由，打包好项目后，页面打开很慢，使用路由懒加载，进入哪个页面，加载哪个页面

- Gzip压缩
在request头中加 accept-encoding: gzip
server接收到http压缩请求，压缩资源，浏览器解压gzip，要花时间，对大型项目，中间节省的传输时间很客观，如果项目小，必要性不大

- 图片压缩优化
前端如何实现图片剪裁？

- 如何选择图片格式，例如png,webp

格式 | 压缩方式 | 透明度| 动画| 浏览器兼容| 透明度| 适应场景
---------|----------|---------|---------|---------|---------|---------
jpeg，有损压缩，不支持透明度，不支持动画，兼容所有，       复杂颜色及形状，尤其是照片
gif，无损压缩，支持透明度，支持动画，     兼容所有，       简单颜色，动画
png，无损压缩，支持透明度，不支持动画，   兼容所有，       需要透明时
SVG，无损压缩，支持透明度，支持动画，     兼容IE8以上所有，简单图形，需要良好的缩放体验，需要动态控制图片特效


## 如何进行code review
持续化集成

## 如何保证组件库的质量的
## 你们对组件库做了哪些优化
## 组件库的样式自定义是如何实现的
## 监控系统如何计算白屏时间和首屏渲染时间，如何进行数据上报，上报到监控系统展示是怎样的过程
白屏的定义有多种。场景不同，白屏的计算方式就不同。
1. 页面元素数小于x，获取页面DOM节点数，小于阈值x，认为白屏，“没有任何内容”
2. 页面出现业务定义的错误码，认为是白屏，“网络或服务异常”
3. 页面出现业务定义的特征值时，认为是白屏，“数据加载中”，“图片加载不出来”
## 如果页面出现白屏，如何排查
## 性能监控平台是如何捕获错误的
## 监控相关的，能说说你了解的performance相关的信息吗，完全可交互时间
## 前端如何做权限控制

怎么做性能优化（异步加载组件...）,如何实现异步加载
前端性能优化（JS原生和React）,前端性能优化（1js css；2 图片；3 缓存预加载； 4 SSR； 5 多域名加载；6 负载均衡）
base64为什么能提升性能，缺点
介绍webp这个图片文件格式
用户体验做过什么优化
整个前端性能提升大致分几类

- 你所知道的前端性能优化方案
DOM层面，CSS样式层面和JS逻辑层面

(1) 减少DOM的访问次数，可以将DOM缓存到变量中；
(2) 减少重绘和回流，任何会导致重绘和回流的操作都应减少执行，可将多次操作合并为一次；
(3) 尽量采用事件委托的方式进行事件绑定，避免大量绑定导致内存占用过多；
(4) css层级尽量扁平化，避免过多的层级嵌套，尽量使用特定的选择器来区分；
(5) 动画尽量使用CSS3动画属性来实现，开启GPU硬件加速；
(6) 图片在加载前提前指定宽高或者脱离文档流，可避免加载后的重新计算导致的页面回流；
(7) css文件在 <head>标签中引入，js文件在 <body>标签中引入，优化关键渲染路径；
(8) 加速或者减少HTTP请求，使用CDN加载静态资源，合理使用浏览器强缓存和协商缓存，小图片可以使用Base64来代替，合理使用浏览器的预取指令prefetch和预加载指令preload；
(9) 压缩混淆代码，删除无用代码，代码拆分来减少文件体积；
(10) 小图片使用雪碧图，图片选择合适的质量、尺寸和格式，避免流量浪费。

React实现的移动应用中，如果出现卡顿，有哪些可以考虑的优化方案

除了通用编程最佳实践之外，你应该期望访问者查看你的代码或设计及其性能影响。它曾经足以将 CSS 置于文档的顶部，而 JS 脚本位于页面底部，但 Web 正在快速移动，你应该熟悉这个领域的复杂性。

关键渲染路径；
图像优化；
延迟加载和捆绑拆分；
何时预取和预加载资源；
减少浏览器回流以及何时将元素提升到 GPU；
浏览器布局、组合和绘制之间的区别。

首屏加载如何优化
一个网页从请求到呈现花了很长时间，如何排查

cdn的用法是什么？什么时候用到？
浏览器的页面优化？
如何优化 DOM 操作的性能
单页面应用有什么SEO方案？
单页面应用首屏显示比较慢，原因是什么？有什么解决方案？

前端性能提升：
  一般会引申到网络，缓存方面的问题

  一般分为几个方面来回答：
  1. server:
  - 使用 cdn
  - 减少不必要的数据返回
  - 使用 gzip
  - 缓存 （etag / expires ...）
  2. content
  - 减少 http 请求 (css sprites / inline image)
  - 不同资源放在不同域下 (http1.1)
  - 延迟加载 / 延迟执行(立即下载，延迟执行[before DOMContentLoaded]defer) / 预加载(preload)
    - async，该布尔属性指示浏览器是否在允许的情况下异步执行该脚本。该属性对于内联脚本无作用 (即没有 src 属性的脚本）。
    - defer，这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发DOMContentLoaded事件前执行。
  - 精简 HTML 结构
  - 压缩资源
3. css
  - in head
  - 较少的层级（之前被问到过是否有统计过层级多与少对性能的实质影响，实际上我是没有做过此类研究，所以知道结论而不懂过程还是欠缺的）
4. js
  - before
  - 减少 dom 访问（在 body 内放置的 JS 代码是否可以访问到 body 标签）
5. webpack:
  - tree shaking 去除没有使用的代码
  - 提取公共包，有被问到
  - 拆分模块，按需加载
  - 优化图片，使用 base64 代替小图
  - file name with hash (etag)

1.了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案

2.了解常见的 Web、 App性能优化方案

3. SEO排名规则、 SEO优化方案、前后端分离的 SEO

4. SSR实现方案、优缺点、及其性能优化

5. Webpack的性能优化方案

6. Canvas性能优化方案

7. React、 Vue等框架使用性能优化方案

cdn的原理，cdn选择最近的缓存服务器是怎么实现

- 性能优化
1. 代码优化(html,css,js)
2. 网络性能优化:
  Cache缓存之强制缓存和协商缓存
  CDN原理及应用
  HTTP压缩之gzip