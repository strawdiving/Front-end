# 浏览器
结构层——HTML标签对网页内容的语义含义做出了描述，不包括内容如何显示的信息。
表示层——CSS完成，描述页面内容应该如何呈现
行为层——负责内容应该如何响应事件这一问题，Javascript和DOM

## 浏览器渲染过程/浏览器如何将一个URL变成一个屏幕上显示的网页
浏览器的渲染引擎将html代码根据css定义的规则，显示在浏览器窗口中的过程。
HTTP请求，DOM树构建，CSS计算，渲染，合成，绘制，自HTTP请求回来，就产生了流式的数据，后面的步骤都尽可能流式地处理前一步的输出，即不需要等到上一步骤完全结束，就开始处理上一步的输出。这样就会看到逐步出现的页面

1. 首先使用HTTP或HTTPS协议，向服务端请求页面
2. 将请求回来的html文件的代码经过解析，构建成DOM树
3. 计算DOM树上的CSS属性（进行CSS解析，生成Style Rules）
   （将DOM Tree和Style Rules合成为Render Tree；把不含样式信息的 DOM 树应用 CSS 规则，变成包含样式信息的 DOM 树)）
4. 根据CSS属性对元素逐个渲染，得到内存中的位图(根据样式和大小信息，为每个元素在内存中渲染它的图形)
5. Layout,排版布局（根据样式信息，计算了每个元素的位置和大小）
6. 一个可选的步骤是对位图进行合成，这会极大增加后续绘制的速度
7. Paint，合成之后，绘制到界面上（遍历Render Tree的节点，将元素绘制到对应的位置。）

CSS 计算是把 CSS 规则应用到 DOM 树上，为 DOM 结构添加显示相关属性的过程；
DOM去匹配css rule的时候head中的css已下载完成了，body中放CSS的话，会重新计算

在构造DOM树的过程中，依次拿到上一步构造好的元素，去检查它匹配了哪些规则，再根据规则的优先级，做覆盖和调整。

把 URL 变成字符流，把字符流变成词（token）流，把词（token）流构造成 DOM 树，把不含样式信息的 DOM 树应用 CSS 规则，变成包含样式信息的 DOM 树，并且根据样式信息，计算了每个元素的位置和大小。那么，我们最后的步骤，就是根据这些样式信息和大小信息，为每个元素在内存中渲染它的图形，并且把它绘制到对应的位置。

渲染：把每个元素对应的盒变成位图，一个元素可能对应多个盒，每个盒对应一张位图。

**排版**
浏览器确定（文字，图片，图形，表格）位置的过程，叫做排版。
最基本的排版方案，是**正常流**排版，包含了顺次排布和折行等规则。

文字排版，规定了行模型和文字在行模型中的排布。行模型规定了行顶，行底，文字区域，基线等对齐方式。
浏览器支持元素和文字的混排，元素被定义为占据长方形的区域，还允许边框，边距和留白，即所谓的 **“盒模型”**
根据盒模型，它占据的空间是由margin,border,padding,width/height等属性之和决定的
在正常流基础上，还支持两类元素：绝对定位元素，浮动元素
- 绝对定位元素把自身从正常流抽出，直接由top,left等确定自身位置，不参加排版计算，也不影响其他元素。由position控制。
需要根据它的包含块来确定位置，和正常流无关的一种独立排版模式，逐层找到父级的非static定位的元素
- 浮动元素，使得自己在正常流的位置向左或向右移动到边界，并占据一块排版空间，由float控制。
先排入正常流，再移动到排版宽度的最左/最右。

### DOM Tree是如何构建的
1. 转码：浏览器将接收到的字符流（二进制数据）按照指定编码格式转换为HTML字符串（Bytes->Characters，即< html>< head>......）
2. 生成Tokens：之后开始parse，将HTML字符串解析成Tokens(Characters->Tokens,token种类大约有标签开始，属性，标签结束，注释，CDATA节点)
3. 构建Nodes：对Node添加特定的属性，通过指针确定Node的父子兄弟关系和所属的TreeScope
4. 生成DOM Tree：通过node包含的指针确定的关系构建出DOM Tree，从父到子，从先到后，一个一个节点构造，并且挂载到 DOM 树上。

### 浏览器是如何判断元素是否匹配某个 CSS 选择器
CSS选择器的解析是**从右向左**解析的。

在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。

若从左向右的匹配，要遍历节点的子节点查找，如果发现不符合规则，需要进行回溯，会损失很多性能。

若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。

两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。
10. src和href的区别
凡是替换型元素，都是使用 src 属性来引用文件的，
链接型元素是使用 href 标签的。
- **为什么通常推荐将 CSS < link> 放置在 < head>< /head> 之间，而将 JS < script> 放置在 < /body> 之前？你知道有哪些例外吗？**
浏览器以逐行方式对HTML文档进行解析，页面加载自上而下，css的下载解析可以和html的解析同步进行。
放到尾部，CSS还没加载完，DOM就已经绘制出来了，造成CSS加载解析完成后的重新渲染。
- **浏览器怎么加载页面的？script脚本阻塞有什么解决方法？请解释 < script >、< script async > 和 < script defer > 的区别。**
script会阻塞文档解析。
当浏览器解析到script的时候，就会立即下载执行，中断html的解析过程，如果外部脚本加载时间很长，就会造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。

流程：浏览器边下载HTML网页边解析；发现script标签，暂停解析，网页渲染的控制权转交给JavaScript引擎
如果script标签引用了外部脚本，就下载该脚本，否则就直接执行；执行完毕，控制权交还渲染引擎，恢复往下解析HTML网页

这两个属性只是script标签在header标签中使用的，如果你把它放在body后面是无效的。
浏览器解析HTML网页，发现带有defer/async的script，继续解析HTML，并行下载script中的外部脚本。
1. defer：浏览器指示脚本在文档被解析后执行，会在 DOMContentLoaded 事件之前（也就是页面DOM加载完成时），script异步加载后不会立刻执行，而是等文档被解析完毕后执行，会按照js脚本书写顺序执行。
2. async：异步加载脚本，脚本加载完毕后立即执行，这导致async属性下的脚本是乱序的，哪个脚本先下载结束，就先执行那个脚本，对script有先后依赖关系的情况不适用。

async和defer都是异步的，仅对外部脚本有效，对于内置的script标签，以及动态生成的script标签不起作用。

一般来说，如果脚本之间没有依赖关系，就使用async属性，如果脚本之间有依赖关系，就使用defer属性。如果同时使用async和defer属性，后者不起作用，浏览器行为由async属性决定。



## **重绘(Repaint)和回流(Reflow)/重排**
1. 回流：当渲染树中一部分因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，节点尺寸需要重新计算，表现为重新生成布局，重新排列元素
2. 重绘：渲染树中一些元素由于样式发生改变，需要更新（只影响外观，风格，不影响布局），例如改变元素背景色

重绘不一定出现重排，重排一定会出现重绘。

重排和重绘代价高昂，会破坏用户体验，让UI展示延迟，重排对性能的影响最大，无法避免时，一般选择重绘。

### 如何触发重排和重绘
任何对用来构建渲染树的信息的改变都会导致一次重排或重绘。
1. 添加、删除、更新DOM节点
2. display:none，隐藏DOM节点——重排和重绘
3. visibility:hidden，隐藏一个DOM节点——只触发重绘，因为没有几何变化
4. 移动或给页面中的DOM节点添加动画
5. 添加一个样式表，调整样式属性
6. 用户行为，如scroll，resize，改变字号
### 如何避免重绘或重排
1. 集中改变样式——通过改变class的方式集中改变样式，如theme的方式，直接改变className，如果动态改变样式，则使用cssText，el.style.cssText += ";
2. 让要操作的元素进行”离线处理”，处理完后一起更新。——使用DocumentFragment创建一个游离于DOM树之外的节点，在此节点上批量操作，最后加入DOM树中，只触发一次回流和重绘,进行缓存操作。document.createDocumentFragment，fragment.appendChild,最后再将fragment加入document.body
3. 提升为合成层
将元素提升为合成层有以下优点：
- 合成层的位图，会交由GPU合成，比CPU处理要快
- 需要repaint时，只需要repaint本身，不会影响到其它层
- 对transform和opacity效果，不会触发layout和paint

提升合成层的最好方式是使用CSS的will-change属性

- 浏览器布局、组合和绘制之间的区别。layout、painting 和 compositing。

**合成（compositing）**
渲染的过程不会把子元素渲染到位图上，合成的过程，就是为一些元素创建一个“合成层”，把一部分子元素渲染到合成的位图上面。目的是提高性能，最大限度减少绘制次数，是一个性能考量。

合成策略是“猜测”可能变化的元素，把它排除到合成之外。
浏览器一般根据position,transform等属性来决定合成策略，“猜测”哪些元素未来可能会变化。
新CSS标准中，规定了will-change属性，由业务代码来提示浏览器的合成策略，提升合成策略的效果。

**绘制**
绘制是把“位图最终绘制到屏幕上，变成肉眼可见的图像”的过程，浏览器只需要把最终要显示的位图交给操作系统即可。
我们已经得到了每个元素的位图，并且对它们部分进行了合成，那么绘制过程，实际上就是按照 z-index 把它们依次绘制到屏幕上。


- **什么是渐进式渲染 (progressive rendering)？**
渐进式呈现是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。
- 打开谷歌浏览器会有多少进程
## 浏览器缓存机制, cookies、sessionStorage 和 localStorage 的使用和区别。
它们的优先级是怎样的 ？
前端存储方式： cookie,localstorage,sessionstorage,Web SQL,IndexedDB
1. cookie，兼容性好，请求头自带cookie方便，缺点是大小只有4k，自动请求头加入cookie浪费流量，每个domain限制20个cookie，使用起来麻烦，需要自行封装
2. localStorage：以键值对为标准方式，操作方便，永久性存储，除非手动删除，大小5M
3. sessionStorage：与localStorage类似，但页面关闭后会被清理，他不能在所有同源窗口中共享，是会话级别的储存方式
4. IndexedDB：NoSQL数据库，键值对存储，可以进行快速读取操作，js操作方便

## HTML离线缓存
常见浏览器内核：chrome,safari——webkit,Firefox——Gecko

浏览器主要组成：
1. 用户界面（地址栏，书签菜单，前进后退按钮
2. 浏览器引擎：用户界面和呈现引擎之间传送指令
3. 呈现引擎：负责显示请求的内容，是html,就负责解析html和css，并将解析的内容显示在屏幕上。
4. 网络：用于网络调用，接口与平台无关，为所有平台提供顶层实现
5. 用户界面后端：用于绘制基本的窗口小部件，如组合框和窗口，其公开了和平台无关的通用接口，在底层使用操作系统的用户界面方法
6. Javascript解释器：解析和执行Javascript代码
7. 数据存储：持久层，浏览器需要在硬盘上保存各种数据

chrome每个标签页都分别对应一个呈现引擎实例，每个标签页都是一个独立的进程

### 请指出浏览器特性检测，特性推断和浏览器 UA 字符串嗅探的区别？
    
    不同浏览器对Javascript的支持程度不一样，有些脚本不一定能正常工作。

    特性检测：

    检测浏览器对Javascript的支持程度。在使用某个特定的方法或属性之前，使用if语句，先测试它是否存在（浏览器是否支持），确保“古老的”浏览器不会因为我的脚本代码出问题，让脚本有更好的向后兼容性。

    **浏览器嗅探技术（browser sniffing）** 
    
    指通过提取浏览器供应商提供的信息来解决向后兼容问题。可以通过Javascript代码检索关于浏览器的品牌和版本的信息，这些信息可以用来改善Javascript脚本代码的向后兼容性。但这是一种风险非常大的技术：1）浏览器可能会'撒谎'，会把自己报告为另一种浏览器，或者允许用户任意修改这些信息，2）为了适用于多种不同的浏览器，浏览器嗅探脚本会越变越复杂，这是个无穷尽的任务，测试组合（供应商和版本）情况越多，代码越复杂和冗长。3）许多浏览器嗅探脚本在进行这类测试时要求浏览器的版本号必须得到精确的匹配，市场上每当有新版本时，就要修改这些脚本。
## 会话机制session

## 浏览器进程和线程
## v8引擎，一段js代码如何执行的
**执行上下文，闭包，作用域，作用域链，事件循环**

在执行一段代码时，JS引擎首先会创建一个执行栈。

JS引擎会创建一个全局执行上下文，并push到执行栈中，这个过程JS引擎会为这段代码中所有变量分配内存并赋一个初始值（undefined），创建完成后，JS引擎进入执行阶段，逐行地执行代码，即为之前分配好内存的变量逐个赋值（真实值）

如果这段代码中存在function声明和调用，JS引擎会创建一个函数执行上下文，并push到执行栈中，创建和执行过程同全局执行上下文，但当函数中存在对其他函数的调用时，JS引擎会在父函数执行的过程中，将子函数的全局执行上下文push到执行栈，这也是为什么子函数能访问到父函数内所声明的变量

还有情况，是子函数执行过程中，父函数已经return了，此时子函数会将父函数的上下文从执行栈中移除，同时JS引擎会为还在执行的子函数上下文创建一个闭包，闭包里保存了父函数内声明的变量及其赋值，子函数仍然能在其上下文中访问并使用这些变量/常量。当子函数执行完毕，JS引擎才将子函数的上下文及闭包一并从执行栈中移除。

JS引擎是单线程的，它是如何处理高并发的》即异步调用时是如何执行的？
比如setTimeout或fetch请求都是non-blocking的，异步调用代码触发时，JS引擎会将需要异步执行的代码移出调用栈，直到等待到返回结果，JS引擎会立即将与之对应的回调函数push进任务队列中等待被调用。当执行栈中已经没有需要被执行的代码时，JS引擎会立刻将任务队列中的回调逐个push进调用栈并执行，这个过程称之为事件循环。

# HTML
1. **doctype(文档类型) 的作用是什么？**
HTML5标准网页声明，告知浏览器的解析器用什么文档标准来解析文档。不同模式会影响浏览器对于CSS代码甚至Javascript脚本的解析。必须声明在HTML文档的第一行。

DTD(文档类型定义)是一组机器可读的规则，它们定义XML或HTML的特定版本中允许有什么，不允许有什么。在解析网页时，浏览器将用这些规则检查页面的有效性并采取相应的措施。

2. **浏览器标准模式 (standards mode) 、几乎标准模式（almost standards mode）和怪异模式 (quirks mode) 之间的区别是什么？**
标准模式，浏览器根据规范(HTML和CSS的定义)呈现页面；
混杂模式，页面以一种比较宽松的向后兼容的方式显示，混杂模式通常模拟老式浏览器的行为以防止老站点无法工作。呈现方面的其他差异比较小，而且是与特定浏览器有关的，包括对于十六进制颜色值不需要#号，使用关键字时将字号增加一级；
几乎标准模式（Mozilla和Safari），除了在处理表格的方式上有细微差异，其他与标准模式相同。
3. **HTML 和 XHTML 有什么区别？**
HTML:html4.0之前先有实现再有标准，导致HTML混乱，松散
XML：主要用于存储数据和结构，可扩展，相比之下，JSON更轻量高效。
XHTML：为了规范HTML，W3C结合XML制定了XHTML 1.0标准，没有增加新的tag，只是按照XML的要求来规范HTML。基于此诞生了HTML5，开头加<! DOCTYPE html>，不加就是兼容混乱的HTML模式，加了就是标准模式。

**如果页面使用 'application/xhtml+xml' 会有什么问题吗？**
使用xhtml,页面结构中必须包含head标签,并且每个标签结构都要关闭,包括空标签。所有标签都要小写。使用了'application/xhtml+xml'之后,部分老浏览器不会支持
5. **meta标签 viewport原理**
meta标签`<meta charset = 'UTF-8>`，用name和content两个属性来定义，描述一个HTML网页文档的属性，如作者，role，网页描述等。常用：
viewpot，控制视口的大小和比例；
http-equiv,相当于http头文件作用，可以设置http缓存过期日期
`http-equiv='expires' content='Wed, 20 Jun... '`
charset,描述HTML文档的编码形式
6. **如果网页内容需要支持多语言，你会怎么做？**
采用统一编码UTF-8方式编码。对提供了多语言版本的网站来说，Unicode字符集是最理想的选择，双字节编码机制的字符集，中英文在Unicode中一律用两个字节表示。
**在设计和开发多语言网站时，有哪些问题你必须要考虑？**
要先把非中文页面的字符集定义为“utf-8”格式。否则可能要重新输入内容。
7. **HTML语义化**
Web语义化：使用恰当语义的html标签，让页面具有良好的结构和含义，如article表示正文内容，p表示段落；（选择何种标签取决于标签本身的语义和文档内容的结构，而不是HTML元素的样式）。

语义化的好处：1. 开发者友好，可读性强，可清晰看出页面结构，维护方便；2. 机器友好，适合搜索引擎的爬虫爬取有效信息。

- 可访问性问题

例如，确保输入复选框具有更大的响应区域（使用标签“for”）。另外还有 role=“button”、role=“presentation”，等等。

8. **HTML5的新特性**
新元素：section,video,nav,aside,header,footer,figure,figcaption,canvas等
input新类型：date,email,url等
新属性：async(用于script)，charset（用于meta)
新的全域属性：draggable，dropzone，spellcheck，contextmenu，contenteditable
**如果把 HTML5 看作一个开放平台，那它的构建模块有哪些？**
标签及属性，地理位置，canvas画布,video,audio,dragdrop,微数据,应用缓存,Web存储,web workers,
服务器发送事件
9. **使用 data- 属性的好处**
HTML的（自定义）数据属性，在生成DOM结构时将数据储存到标准的HTML元素中作为额外信息，可以通过js（element.dataset）访问他，获取自定义数据，不用ajax去后台取得数据。

前端框架出现后就不流行了。

10. offsetTop和scrollTop和scrollHeight分别代表什么

- **为什么要在图像标记中使用srcset属性？ 解释浏览器在评估此属性的内容时使用的过程。**
24. History操作
26. Canvas和SVG
canvas通过Javascript来绘制2D图形，SVG是一种使用XML描述2D图形的语言
14. **拖拽实现**
27. SEO
在了解搜索引擎自然排名机制的基础上，对网站进行内部及外部的调整优化，改进网站在搜索引擎中关键词的自然排名

### 如果你参与到一个项目中，发现他们使用 Tab 来缩进代码，但是你喜欢空格，你会怎么做？
- 
- 如果今年你打算熟练掌握一项新技术，那会是什么？
- 请谈谈你对网页标准和标准制定机构(standards bodies)重要性的理解。
- 什么是 FOUC (无样式内容闪烁)？你如何来避免 FOUC？
- 请解释什么是 ARIA 和屏幕阅读器 (screenreaders)，以及如何使网站实现无障碍访问 (accessible)。
- 请解释 CSS 动画和 JavaScript 动画的优缺点。

流媒体查询
mysql 和 mongoDB 有什么区别？
数据库知识、操作系统知识
click在ios上有300ms延迟，原因及如何解决
移动端的适配，rem+媒体查询/meta头设置
移动端的手势和事件；
unicode，utf8，gbk编码的了解，乱码的解决
数据库的四大特性，什么是原子性，表的关系

正则表达式

# 测试相关问题
- 对代码进行测试有什么优缺点？
- 你会用什么工具测试你的代码的功能？
- 单元测试与功能/集成测试的区别是什么？
- 代码风格 linting 工具的作用是什么？
如JSLint，可以查找Javascript中的语法错误和常见的编码错误。
- 请谈谈你喜欢的开发环境。
- 您能否解释一下前端安全方面的常见技术或遇到的最新问题？
- 您个人对最近的项目采取了哪些措施来提高代码的可维护性？
- 你最熟悉哪一套版本控制系统？
- 你能描述当你制作一个网页的工作流程吗？
你觉得前端体系应该是怎样的？