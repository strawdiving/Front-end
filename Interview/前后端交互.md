# 为什么要前后端分离
已成为业界标准，通过nginx+tomcat的方式，也可以中间加node.js有效的进行结偶，并且前后端分离会为以后的大型分布式结构，微服务架构，多端化服务打下坚实基础。

核心思想：前端html页面通过ajax调用后端的restful api接口，并使用json数据进行交互。

Web服务器：nginx，apache这类服务器，一般只解析静态资源
应用服务器：tomcat, jetty, resin这类服务器可以解析静态和动态资源，但解析静态资源但能力没有web服务器好

前后端分离让两端工程师更加专注于各自的领域。

- 对后端工程师，

注重：java基础，设计模式，jvm原理，spring+springmvc原理及源码，linux，mysql事务geli与锁机制，mongodb, http/tcp，多线程，分布式架构，弹性计算架构，微服务架构，java性能优化，及相关对项目管理等；

追求：高并发，高可用，高性能，安全，存储，业务等
- 对前端工程师：

注重：html5/css3, angularjs/vue/react, bootstrap, jquery, less/sass, gulp/webpack, nodejs, Google v8引擎，javascript多线程，模块化，面向切面编程，设计模式，浏览器兼容性，性能优化等;

追求：页面表现，速度流畅，兼容性，用户体验等

新的方式是：浏览器发送请求--直接返回html页面（前端控制路由和渲染页面）--html页面负责调用服务端口产生数据（通过ajax等，后台返回json格式数据）--填充html，展现动态效果，在页面上进行解析并操作dom

大量并发浏览器请求---web服务器集群（nginx）---应用服务器集群（tomcat）---文件/数据库/缓存/消息队列服务器集群

同时可以分模块，还可以按业务拆成一个个的小集群，为后面架构升级做准备。

1. 前后端分离的优势
- 可实现真正的前后端解耦，前端服务器使用nginx。

前端web服务器放的是css,js，图片等一系列静态资源，甚至可以将静态资源放到特定的文件服务器，如阿里云的oss，并使用cdn加速；

前端服务器控制页面引用/跳转/路由，前端页面异步调用后端的接口，后端/应用服务器使用tomcat，加快整体响应速度。

这里需要使用一些前端工程化的框架比如nodejs,react,router,redux,webpack,vue等

- 发现bug，可以快速定位是谁的问题，如页面逻辑，跳转错误，浏览器兼容问题，数据未提交成功，脚本错误，页面样式等，都是前端负责；接口数据出错，数据未提交成功，应答超市等，由后端解决
- 大并发情况下，可以同时水平扩展前后端服务器，如淘宝首页就需要2000+前端服务器做集群来扛住日均几亿的日均pv
- 减少后端服务器的并发/负载压力。除了接口以外的其他所有http请求全部转移到前端nginx上，请求的接口调用tomcat，参考nginx反向代理tomcat，且除了第一次页面请求外，浏览器会大量调用本地缓存
- 即使后端服务挂了，前端也可以正常访问，只是没有数据而已
- 对多端应用，如和微信相关的轻应用，则接口完全可以共用；如果由app相关的服务，只需要一些代码崇高，也可以大量复用接口，提高效率
- 页面显示的东西再多也不怕，因为是异步加载
- 增加代码的可维护性/易读性
- 提升开发效率，前后端可以并行开发
- nginx支持页面热部署，不用重启服务器，前端升级更无缝；在nginx中部署证书，外网使用https访问，并且只开放443和80端口，内网还有http，性能和安全都有保障
- 前端大量组件代码得以复用、组件化，提升开发效率。

2. 注意事项
- 要制定好前后端接口文档，后端要写好测试用例，推荐chrome的postman或soapui,jmeter，server层的测试用例用junit写
- 前端需要机制应对后端请求超时以及后端服务宕机的情况，友好地展示给用户
- 数据校验，前后端都需要做

- 对于静态资源，可以考虑放到类似阿里云的oss这类文件服务器上（普通的服务器/操作系统，文件多了以后，io会有严重的性能问题），再在oss配上cdn，页面速度快，nginx负载会进一步降低
- 要做轻量级微服务架构，使用node.js做网关，node.js的好处还有利于seo优化，国内的引擎爬虫只抓取静态数据，不解析页面中的js
- 跨域问题，一般使用nginx反向代理都不会有跨域问题，除非把前端服务和后端服务分为两个域名
- 如果要做多端应用，要使用token机制，使用缓存，做单点登录，对token机制对安全性问题，考虑jwt
- 前端项目可以加入mock测试（构造虚拟测试对象来模拟后端，可以独立开发和测试），后端需要详细对测试用例，保证服务的可用性与稳定性。

前端项目和后端项目是两个项目，放在不同的服务器，需要独立部署，前端只关注页面的掩饰与动态数据的解析&渲染，而后端专注于具体业务逻辑。
# Swagger
公司项目一般使用swagger，由后端来模拟业务数据。

swagger是一个REST APIs文档生成工具，它从代码注释中自动生成文档，可以跨平台，开源，支持大部分语言，社区好。

Swagger UI好处：支持多种接口格式、测试方便、支持get／post／jsonp等多种发送方式。

前后端用swagger定好全部接口，前端人员按照接口发送和返回进行页面制作。后端通过swagger就能自行调试接口。

Swagger UI是通过读取Swagger Edit的导出的YAML／JSON文件，来进行接口测试

总结：使用swagger，就是把相关信息存储在她定义的描述文件里（yml或json），再通过维护这个描述文件可以取更新接口文档，以及生产各端代码。Springfox-swagger，可以通过扫描代码去生成这个描述文件，连描述文件都不需要再去维护了。所以信息都在代码里，代码即接口文档。

ps：Swgger UI的站点域名要和发送请求的域名一样。不然浏览器会报跨域错误。
[Swagger UI安装与使用教程](https://blog.csdn.net/rth362147773/article/details/78966395)

[Swagger介绍及使用](https://blog.csdn.net/weixin_42554191/article/details/105742386)

前端访问 http://10.20.53.80:8083/swagger-ui.html#/ ，即可使用所有的 Mock接口。

通过这套规范，你只需要按照它的规范去定义接口及接口相关的信息。再通过Swagger衍生出来的一系列项目和工具，就可以做到生成各种格式的接口文档，生成多种语言的客户端和服务端的代码，以及在线接口调试页面等等。这样，如果按照新的开发模式，在开发新版本或者迭代版本的时候，只需要更新Swagger描述文件，就可以自动生成接口文档和客户端服务端代码，做到调用端代码、服务端代码以及接口文档的一致性。

需要编写yml或json格式的描述文件。
以作为Java届服务端的大一统框架Spring，迅速将Swagger规范纳入自身的标准，建立了Springfox。通过在项目中引入Springfox，可以扫描相关的代码，生成该描述文件，进而生成与代码一致的接口文档和客户端代码。
SWAGGER官网主要提供了几种开源工具，提供相应的功能：
- Swagger Editor: 类似于markendown编辑器的编辑Swagger描述文件的编辑器，该编辑支持实时预览描述文件的更新效果。也提供了在线编辑器和本地部署编辑器两种方式。
- Swagger UI:提供了一个可视化的UI页面展示描述文件。接口的调用方、测试、项目经理等都可以在该页面中对相关接口进行查阅和做一些简单的接口请求。该项目支持在线导入描述文件和本地部署UI项目。
- Swagger Inspector: 是一个可以对接口进行测试的在线版的postman。比在Swagger UI里面做接口请求，会返回更多的信息，也会保存你请求的实际请求参数等数据。
- wagger Codegen: 通过Codegen 可以将描述文件生成html格式和cwiki形式的接口文档，同时也能生成多钟语言的服务端和客户端的代码。支持通过jar包，docker，node等方式在本地化执行生成。也可以在后面的Swagger Editor中在线生成。

一般来说，接口文档都是由服务端来编写的。

**项目开发阶段**，服务端开发可以视情况来决定是直接编写服务端调用层代码，还是写Swagger描述文件。建议是如果项目启动阶段，就已经搭好了后台框架，那可以直接编写服务端被调用层的代码（即controller及其入参出参对象），然后通过Springfox－swagger 生成swagger json描述文件。如果项目启动阶段并没有相关后台框架，而前端对接口文档追得紧，那就建议先编写swagger描述文件，通过该描述文件生成接口文档。后续后台框架搭好了，也可以生成相关的服务端代码。

**项目迭代阶段**，后续后台人员，无需关注Swagger描述文件和接口文档，有需求变更导致接口变化，直接写代码就好了。把调用层的代码做个修改，然后生成新的描述文件和接口文档后，给到前端即可。真正做到了一劳永逸。


两种流程：

一、
1. 开始阶段
- 编写yml或json格式的swagger描述文件
- 生成服务端被调用层代码
- 项目中引入Springfox-swagger
2. 项目迭代阶段
- 生成swagger/json描述文件
- 生成接口文档
- 生成客户端代码
- 修改客户端被调用层代码
- 生成swagger/json描述文件

迭代阶段 循环
二、
1. 开始阶段
- 项目中引入Springfox-swagger
- 开发服务端被调用层代码
2. 迭代阶段，同一

## Swagger前端mock
在提供接口文档时，把所有接口的模拟请求响应数据也提供给前端。或有mock系统，直接将这些模拟数据录入到mock系统中，可以提高前端开发效率，减少许多在联调时才会发生的问题。

在代码中加入swagger的注解，可以让接口文档更详细，如果把每个出入参数的示例值都配上，前端可以直接从接口文档拿到模拟数据。

# Postman

## pm2
pm2是一个带有负载均衡功能的Node应用的进程管理器，并保证进程永远都活着，0秒的重载。

主要作用是node.js集群。本地开发环境，要开启node服务，实现某个功能，就要在控制台执行如node app.js来开启对应的node服务，但是只要关闭这个控制台窗口，就没有对应的服务进程了。在生产环境，只要执行一次`pm2 start app.js`,就可以一直运行这个服务进程。

配置文件，在项目根目录新建配置的json文件，初次启动执行
`pm2 deploy xx.json production setup`

然后执行
`pm2 deploy xx.json production `

可以在服务器，通过pm2 list 和 pm2 logs查看部署成功的应用和部署日志

以后每次修改的项目push到github后，直接在本地通过`pm2 deploy xx.json production`就可以更新线上的内容。
## 部署
前端部署，nodejs作为中间层，作为静态文件服务器，比如将webpack打包后的dist作为静态资源。

使用Nginx进行反向代理，客户端发起请求，当用户要访问静态资源时，交由文件服务器直接压缩后返回前端，若是动态资源请求，则经过动态资源服务器生成动态数据返回给前端。

资产文件交付——在大型应用程序中，独立团队拥有自己的代码库是常有的事。这些不同的代码库可能彼此依赖，每个代码库通常都有自己的管道来发布代码变更。你的设计需要考虑如何基于依赖项进行资产文件的构建（代码拆分）、测试（单元测试和集成测试）和部署。你还需要考虑如何通过 CDN 交付资产文件或者内联它们来减少网络延迟。

- 服务器代理转发如何处理cookie(nginx)
```javascript
proxy_cookie_domain localhost example.org;
proxy_cookie_domain ~\.([a-z]+\.[a-z]+)$ $1;

proxy_cookie_path /one/ /;
proxy_cookie_path / /two/;
```

如何做前后端分离

前端渲染和后端渲染的优缺点
在不使用后端模板渲染的情况下,如何做前端数据直出(不使用异步请求数据)?

SSR适用什么场景?
渲染——客户端渲染（CSR）、服务器端渲染（SSR）和全局渲染；

RESTful常用的Method

前后分离的系统，一个请求出错了，如何中断其它请求？

开发提速
1.熟练掌握一种接口管理、接口 mock工具的使用，如 yapi
2.掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题
3.理解 TDD与 BDD模式，至少会使用一种前端单元测试框架

