设计出常见应用程序的前端架构时，你也不应该感到惊讶。这些问题通常含糊不清，比如“设计一个像 Pinterest 这样的网站”或者“如何构建购物结账服务？”
需要考虑：
1. 渲染——客户端渲染（CSR）、服务器端渲染（SSR）和全局渲染；
2. 布局——如果你正在设计被多个开发团队使用的系统，需要考虑进行组件化，以及是否需要开发团队通过指定标记来使用组件；
3. 状态管理，例如在单向数据流或双向数据绑定之间做出选择。你还应该考虑你的设计是采用被动式还是反应式编程模型，以及组件如何相互关联，例如是 Foo->Bar 还是 Foo->Bar；
4. 异步——你的组件可能需要与服务器进行实时的通信。在设计时需要考虑使用 XHR 或双向调用。如果你的面试官要求你支持旧浏览器，那么你需要在隐藏 iFrame、script 标签或 XHR 之间做出选择。如果没有，你可以建议使用 websocket，或者使用服务器发送事件（SSE），这样会更好；
5. 关注点分离——Model-View-Controller（MVC）、Model-View-ViewModel（MVVM）和 Model-View-Presenter（MVP）模式；
6. 多设备支持——你的实现是否同时支持 Web、移动 Web 和混合应用程序，还是为每一种场景提供单独的实现？如果你正在构建像 Pinterest 这样的网站，你可能会考虑在 Web 上使用三列，但在移动设备上只使用一列，你的设计将如何处理这个问题；
7. 资产文件交付——在大型应用程序中，独立团队拥有自己的代码库是常有的事。这些不同的代码库可能彼此依赖，每个代码库通常都有自己的管道来发布代码变更。你的设计需要考虑如何基于依赖项进行资产文件的构建（代码拆分）、测试（单元测试和集成测试）和部署。你还需要考虑如何通过 CDN 交付资产文件或者内联它们来减少网络延迟。

- Model-View-Controller（MVC）、Model-View-ViewModel（MVVM）和 Model-View-Presenter（MVP）模式

- 设计模式(要求说出如何实现,在开发/项目中的实际应用,优缺点):
熟练使用前端常用的设计模式编写代码
前端开发中用到哪些设计模式
Vue/React中哪些功能用到了哪些设计模式,理解框架源码中对设计模式的应用
工厂模式
中介者模式
发布订阅模式
单例模式,
装饰器模式,
代理模式,
观察者模式，观察者模式里面使用的数据结构(不具备顺序 ，是一个list)
生产消费者模式
观察者和发布-订阅的异同以及实际应用（各自适用于什么场景）

设计模式
   设计模式感觉也是 将面向对象思想 再度抽象成现实中 某些特定模式

- 面向对象
面向对象的编程思想
   1. 类的抽象
   2. 对象的封装, 继承
       为了更好的去管理数据, 分类数据     实现高内聚, 低耦合

面向对象三要素
JS面向对象之封装,继承,多态的体现和应用?
除js之外的面向对象语言


- 介绍单页面应用和多页面应用

# 什么是设计模式
- 设计模式是编程遇到的问题的可重用解决方案
- 主要为了解决对象的生成和整合问题
- 即，设计模式可以作为可应用于现实世界编程问题的模板

# 设计模式分类
分为三种类型：
1. 创建型模式
2. 结构型模式
3. 行为型模式

## 创建型模式 —— 用于对象的生成和生命周期的管理
创造模式可以决定生成哪些对象，提高了程序的灵活性。
- 抽象工厂模式
- 生成器模式
- 工厂方法模式
- 单例模式
- 原型模式

### 抽象工厂模式
像一个工厂，但一切都被封装起来：
- 提供对象的方法
- 构建对象的工厂
- 最终的对象
- 最终对象包含使用策略模式的对象

策略模式只是使用组合的方式，即它的类字段实际上是对象本身。

用处：可以创建类簇类的对象，而不需要指定具体的类，这使得抽象工厂很灵活

通过抽象工厂模式可以对任何类簇对象进行建模并通过统一的接口供外部对象使用。

抽象工厂唯一不好的地方是它可能变得非常复杂。

### Javascript的生成器模式（Builder模式）
Builder 模式是一种用于创建由其他对象组合构成的对象的模式。创建部件的方法应该独立于主对象。另外，为了从业务方隐藏部件的创建细节，两者是相互独立的。

在使用生成器模式时，生成器知道所有的细节，且创建细节完全对其他相关类屏蔽。

### 工厂方法模式
根据定义，只要想一个方法返回公共超类的几个可能的类中的一个，就可以使用工厂模式。

假设我想随机向屏幕上射击敌人。那么如果所有东西都硬编码好了，并且不知道敌人的具体类型会让处理变得很困难。

但是，假设我创建了一个随机数生成器，每个可能的敌人类都由一个数字代替，并可以由该随机数生成器返回。

然后可以将这个数字发送给工厂对象，这样可以返回一个动态创建的敌人。

所以，MOL 的主要概念非常重要，我们希望能够在运行时选择类，这就是工厂模式能够提供的。

何时使用工厂方法模式？

当不知道需要何种类型的对象时可以使用工厂方法模式。

但是，有一点需要注意，确保所有潜在的类都具有相同的子类层次结构，这意味着在继承路径上有相同的父类。

可以使用工厂模式来集中类别选择的代码。或是不希望用户知道每一个可能的子类时。

### 单例模式
当想要避免实例化多个对象时使用单例模式。单例使得只能从类实例化一个对象。

拼字游戏里使用一个类容纳所有可能的字母，并且拼字游戏是一款非常常见的棋盘游戏，这里使用单例模式是很明智的选择。

这个单例类包含所有可能的拼字游戏字母，以便玩家可以使用这个单例类取得所有字母，不同玩家可以同时请求获取。

单例使得每个玩家都共享相同的字母列表，每个玩家可以根据这个字母列表来拼接自己的单词。

【定义】：保证一个类只有一个实例，并提供一个访问它的全局访问点。

将全部职责集中在一个实例上，避免无谓的浪费。因为只有一个实例，要保证想用的地方都能访问到。

【应用】：使用相对频繁，功能强大， 创建一次相对消耗性能多的可以使用单例模式
【优点】：唯一实例，节约内存开销
【缺点】：违背“单一职责”原则，不好维护，不容易扩展，不适用于容易变化的实例

### 原型模式
想要通过克隆或拷贝对象来生成对象时，这就是原型模式。

通过原型模式可以在运行时添加已知父类的子类实例。

当有许多类只在运行时需要使用时可以使用原型模式。原型模式的好处之一是减少了创建多个子类。

## 结构型模式
这类模式描述了向现有对象添加功能的不同方式。简单地说，这个模式着重于解耦。对象的接口实现模式如下：
- 适配器模式
- 桥接模式
- 组合模式
- 装饰者模式
- 外观模式
- 享元模式
- 代理模式

### 适配器设计模式
适配器设计模式允许使用两个完全不兼容的接口一起工作，正如其名字一样，适配不同接口。

假设你墙上的插座只有两座插头，但是你想连接一个三座的插头，这时就需要适配器了。当客户期望使用目标接口是两座插头，但是你只有三座插头，这就是适配器将要执行的操作 把三座转换成两座。

适配器模式允许使用任何现有接口适配为目标接口。

从另一个角度看任何类都可以协同工作只要适配器解决了所有类都必须实现相同接口的问题。

### 桥接模式
官方定义是将抽象与其实现分离开来，因此两者可以独立变化。

该模式用于将抽象与其实现分开，以便两者都可以独立修改。该模式包含一个用于桥接抽象类和实现类的接口。通过桥接模式，两种类型都可以修改而不会相互影响。

- 桥接模式实现指南
当想要避免抽象与其实现之间的永久绑定时可以使用桥接模式。

抽象和它们的实现都应该可以通过子类进行扩展。当抽象的实现有变化时不应该影响到调用方，及调用方不需要重新编译。

当需要在多个对象之间共享一个实现时，可以选择这种模式。

最后我们希望完全对调用方隐藏抽象的实现。
### 组合模式
它允许统一处理单个对象和对象组合，这是组合设计模式的典型定义。

组合模式可以表示为部分 - 整体的层次结构。该结构的组件又可以划分为更小的组件。

一个更合乎逻辑的定义是组合设计模式是用来结构化数据或单独表示整个对象的每个部分的互相操作。

### 装饰者模式
动态的为一个对象附加额外的功能，装饰模式可以不通过继承来实现功能扩展。

这种模式属于结构设计模式类别，也被称为包装模式，装饰设计模式解决了在不改变对象现有结构的情况下添加附加功能的问题。

另外，该模式创建了一个装饰器类，它包装原始类并在运行时向对象添加新的行为或操作。

当选择这种模式时，需要动态地向单个对象添加新的功能，并且而不会影响其他对象。

例如，在有些情况下，为原有代码添加新的功能可能会很困难，用修饰器修改代码会更容易些。

通过继承来实现功能扩展会产生大量的子类，并且有可能这些子类还不足以覆盖所有需要扩展的功能。

当无法查看类定义或无法继承时，需要选择装饰模式。

例如，尽管类被封装起来无法修改，通过装饰模式仍然可以进行扩展，无法通过继承来实现功能扩展的情况下，选择装饰模式。

【定义】：装饰者模式可以动态地给某个对象添加一些额外的职责
         能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责
【理解】：
【应用】：
【优点】：扩展性好，随变化而变化，灵活，甚至预测需求
【缺点】

### 外观模式
为子系统中的一组接口提供统一接口。外观模式定义了一个更高层次的接口，使子系统更易于使用。

简单来说是外观模式隐藏了子系统的实现复杂性，为我们提供了一个简洁的接口。该接口负责调用现有子系统的功能。

- 外观模式实现指南

当我们想为子系统提供一个简单的接口时需要使用外观模式。随着子系统的发展，子系统往往会变得更加复杂。

当我们在应用一些模式时，大多数模式会导致更多的类创建出来，这使得子系统可用性更好，更容易自定义需要的功能，但对于不太需要自定义的业务方而言，它也变得更加困难。

外观模式将子系统包装成一个简单默认的接口，足以应付大多数情况的使用。

另外，当业务方和子系统的实现存在过多依赖时也可以选择外观模式。

在这种情况下，外观模式将子系统从业务方和其他子系统中分离出来，从而提高子系统的独立性和可移植性。

到目前为止，如果子系统过于耦合，那么可以通过外观模式提供的接口来简化子系统之间的依赖。

### 享元模式
当需要创建大量相似对象时需要使用享元模式，这里的大量是上万的量级而不是平时接触的上百。

享元模式通过共享对象的相似部分，避免重复创建，来达到减小内存的使用。

【定义】：一种用于性能优化的模式，核心是运用共享技术来有效支持大量细粒度的对象
【理解】：书上举例说：有100种衣服，让100个模特一人试一件 和 一个模特试100件，假如请一个模特是100块（创建对象消耗），你愿意请多少个模特，一个模特试100件衣服肯定比100个模特慢，所以，享元模式是一种利用时间换取空间的优化模式
【应用】：如果考虑需要复用元对象的话，建议定义好元对象，使用的地方深拷贝或浅拷贝一下再使用，这样其他地方也可以使用而不破坏元对象了
      适用于：
        - 一个程序中使用了大量的相似对象
        - 由于使用了大量对象，造成了很大的内存开销
        - 对象的大多数状态都可以变为外部状态
        - 剥离出对象额外部状态后，可以用相对较少的共享对象取代大量对象
【优点】：性能优化，解决大量对象带来的性能问题
【缺点】


### 代理模式
代理是一个将被用来限制访问另一个类的类。

这可能是出于安全的考虑，通过代理来决定需要代理的对象哪些方法是可用的。

【定义】：代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问
【应用】：惰性加载，如图片懒加载
         缓存代理，如304，Memorization?
【优点】：分解本体职责——单一职责原则，解决本体暂时性无法处理一些请求，解决性能
【缺点】：编码需要维护代理和本体的联系；编码需要保持代理和本体接口的一致性

## 行为型模式
描述了对象如何相互作用。

模式如下：
- 观察者模式
- 策略模式
- 责任链/职责链模式
- 命令模式
- 解释器模式
- 迭代器模式
- 中介者模式
- 备忘录模式
- 状态模式
- 模板方法模式
- 访问者模式


### 观察者模式
当另一个对象更改时需要其他对象接收更新。当需要将更新发送给多个订阅者时，可以使用观察者模式来完成。

- 好处
松耦合。 对象或发布者完全不用知道观察者或订阅者的存在，发布 - 订阅， OLP 的基本术语使用的是对象 - 观察者。
- 坏处
观察者模式唯一的缺点是对象或发布者可能发送对观察者，订阅者无关紧要的更新。

【定义】
【理解】
【应用】
【优点】
【缺点】

### 发布-订阅模式
【定义】：它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知。JS开发中，一般用事件模型来替代传统的发布-订阅模式。
【理解】：Vue的Bus通信就是一种发布-订阅模式，中间的Vue实例就是调度层。这个必须先监听再推送，推送过的再添加监听就监听不到了。观察者模式指的是观察者与被观察者之间直接的通讯
【应用】：发布者的每次发布可以缓存起来，等有新的订阅者时，再把之前缓存的消息一起发送给新的订阅者。
         现在流行的MVVM框架源码都用到发布-订阅模式
         addEventListener，添加事件监听
【优点】：可以随意增加或删除订阅者，不会影响发布者的代码编写，耦合度低
【缺点】：消耗时间、内存，嵌套过深导致难以追踪

### 策略模式
如果要定义一个类，该类将具有与列表中的所有其他行为相似的行为，可以使用策略模式。

通过策略模式可以动态的创建全新的不同类型的飞行类动物。

当需要动态决定需要使用的行为时可以使用策略模式。
- 好处
它通常会减少很长的条件列表，所以如果你看到使用许多不同类型的条件时，策略模式会很有帮助。当然，还避免了重复的代码。

策略模式可以防止其他类的变化影响到当前类。也可以向业务方隐藏复杂和敏感代码。

坏处：策略模式会增加对象和类的数量。

【定义】：定义一系列的算法，把它们一个个封装起来，并且使他们可以相互替换。
【理解】：如果有很多if/else或switch时，可以考虑策略模式替换那些分支。把分支转成配置，利用配置参数可以减少很多分支。
         一般情况下，把某个职责委托给一个策略对象，策略对象的每一个键值对是一个分支，命名规范的话，key也是一个很好的注释，对象比分支更易读易扩展，代码量更少。

         开发-封闭的设计原则：对扩展开放，对修改封闭，把容易改变的地方分离出来；策略对象就是被分离出来的容易被改变的地方
【应用】：表单校验，算法分类，其他选择性较多且目标相同的需求
【优点】：避免多重条件选择语句；遵循开发-封闭原则，代码更易阅读、维护和扩展，一定程度上减少代码量，提高可复用性
【缺点】：违背最少知识原则，使用策略对象处耦合性大

### 责任链/职责链模式
责任链模式有一组对象，期望它们之间能够解决问题，如果第一个对象无法解决它，则将数据传递给责任链中的下一个数据。

通过多个接收者对象来处理请求，避免将请求的发送者耦合到其接收者。将接收对象串联起来，传递请求直到被其中一个处理掉。

责任链模式为请求创建一系列接收者对象。 在这种模式下，通常每个接收器都包含对另一个接收器的引用。

如果一个接收者不能处理该请求，则它将请求传递给下一个接受者。

【定义】：使得多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
【理解】：作用域、原型链、事件冒泡跟职责链是不是很相似，个人觉得跟promise也有点相似，从接口获取到数据然后一层一层的promise去筛选过滤最后达到业务层，业务层拿到数据处理业务逻辑or呈现数据
【应用】：管理代码、其他类似事件冒泡的需求
【优点】：降低发起请求的对象和处理请求的对象之间的耦合性
【缺点】：链条太长对性能有较大影响


### 命令模式
命令设计模式是一种行为设计模式，其对象用于表示和封装稍后调用某个方法所需的所有信息。该信息包括方法名称，拥有方法的对象和方法参数的值。

基本上，它允许你做的是存储代码清单，在稍后或多次执行，并且通常使用命令模式可以撤销命令。

当这些封装的对象调用 execute() 方法，业务方或程序会执行指定命令或一段代码。

然后，调用者对象在调用时会传递命令给命令接收者，命令接收者拥有实际想要执行的代码，一旦从调用者接收到命令就立马执行。

例如有个"TurnTVOn”的命令对象，然后一个“DeviceButton”的对象，一旦"DeviceButton"对象被调用就会发送"TurnTVOn"命令。所有这些之间的接口可以使用多态，所以无论何时调用 TurnTVOn，该方法将由命令接收者执行。

### 解释器模式
解释器模式很容易被忽略，并且网上很少有使用这种模式。

但是，如果与 JavaScript 反射技术结合使用，会变得非常有用。它用于将数据的一种表示转换为另一种表示。

### 迭代器模式
迭代器模式提供一种统一的方式来访问不同类型的对象集合。

例如，Array，ArrayList 和 HashTable，这三个集合包含相同类型的对象，通过迭代器可以取到集合里的每一个元素，并做相同的处理。

迭代器模式做的是提供统一的方式来循环遍历这些不同类型的集合。

【定义】
【应用】
【优点】
【缺点】

### 中介者模式
用于处理相关对象之间的通信。所有通信由中介者完成，通信双方不需要了解对方的任何信息。

更严格的定义是，中介者模式允许通过封装不同对象之间相互作用和相互通信的方式来实现松耦合，并且中介者模式允许每个对象的行为彼此独立地变化。

【定义】
【应用】
【优点】
【缺点】

### 备忘录模式
用于存储对象以前状态的模式，首先，备忘录模式需要一个备忘录对象用于存储对象的不同状态，不同的状态及一些字段拥有不同的值。

然后，用于从当前目标备忘录对象读写值的初始对象，创建新的备忘录对象并赋值给当前备忘录对象。

最后，内部是一个 ArrayList 对象用于持有之前所有的备忘录对象，该 ArrayList 对象同时用于存储和检索备忘录对象。
### 状态模式
它允许对象在其内部状态改变时改变其行为，这样让对象看起来改变了它所属的类。

状态模式主要分为三个部分：

首先，将拥有所谓的“上下文”或“账户”，它将要做的是维护一个将定义当前状态的 ConcreteState 子类的实例。

然后，拥有“状态”，该状态定义了一个用于封装与上下文特定状态关联的行为接口。

最后是具体的状态，每个子类将实现与上下文状态相关的行为。

【定义】：关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变
【理解】：和策略模式在实现上有一定相似之处，但目的不一样。策略模式每条策略都是平行平等的，而状态模式最大的区别是，所以状态都是预先定义好的
如电风扇1-5档是状态模式，1-5档是预先定义好的，结果是每档风力大小不一样；
从上海到伦敦旅游，选择交通方式是策略模式，坐汽车、火车、飞机、船是平行的，结果是到达终点

改变行为发生在状态模式内部；
策略模式是外部选控制的，用户也不需要了解状态模式的内部细节。

状态模式是遵循“最少知识原则”的。

【应用】：状态机，把状态抽离出来单独封装在一个对象里面，直观方便，只需call(状态机)一下使用。
【优点】：容易增加新状态或者切换当前状态，请求动作和状态中封装的行为解耦，易维护扩展
【缺点】：逻辑分散不易读

### 模板方法模式
用于创建一组执行类似方法的子类。

要实现它，需要创建一个抽象类，它将包含一个名为模板方法的方法。

创建包含称为模板方法的抽象类，并且模板方法包含每个子类对象将调用的一系列方法调用。在某些情况下子类也会重载一些不合适的方法调用。

### 访问者模式
访问者模式允许将方法添加到不同类型的类中 - 但它们不必是不同的类型 - 只会让复杂度有所增加，并不会对类有太多修改。

这可以根据所使用的类制作完全不同的方法。

也可以说访问者模式可以为现有类创建外部类来进行扩展以避免对原有类做修改。