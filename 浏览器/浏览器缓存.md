# 浏览器缓存
缓存：有效降低网络时延，减少大量请求对于服务器的压力。
1. 减少冗余的数据传输，可节省流量
2. 缓解带宽瓶颈问题，可更快加载页面
3. 缓解瞬间拥塞，可缓解原始服务器的压力
4. 降低距离延时，加快响应速度

## 浏览器缓存机制, cookies、sessionStorage 和 localStorage 的使用和区别。
前端存储方式： cookie,localStorage,sessionStorage,Web SQL,IndexedDB

共同点：都是保存在浏览器端、且同源的

不同点：
  1. cookie，兼容性好，请求头自带cookie方便，数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。
    cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下
    但自动请求头加入cookie浪费流量，每个domain限制20个cookie，使用起来麻烦，需要自行封装
    sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。

  2. 存储大小限制不同
    cookie数据大小只有4k，sessionStorage和localStorage可以达到5M
  3. sessionStorage：仅在当前浏览器窗口关闭之前有效；页面关闭后会被清理，是会话级别的储存方式
    localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作持久数据；
    cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭
  4. 作用域不同
    sessionStorage：不能在所有同源窗口中共享，即不能在不同的浏览器窗口中共享，即使是同一个页面；
    localStorage：在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在
    cookie: 在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在

IndexedDB：NoSQL数据库，键值对存储，可以进行快速读取操作，js操作方便
### 浏览器缓存，强缓存和协商缓存（从200缓存，到cache到etag再到）
1. client向server请求资源
2. server返回资源，并通过**响应头决定缓存策略**
3. client根据响应头的缓存决策决定是否缓存资源，如果要缓存，就将响应头与资源缓存下来
4. 在client再次请求并命中资源时，此时client会去检查上次的缓存策略，根据策略的不同，是否过期等决定是直接读取本地缓存，还是和server协商缓存

**强缓存（优先级较高）：**
离不开响应头Cache-Control和Expires
- Cache-Control，优先级高于Expires，
`Cache-Control:max-age =3145250450`，用max-age控制过期时间（相对时间）
- Expires，表示过期时间（绝对时间），受限于本地时间，如果修改了本地时间，可能导致缓存失效

1. 如果是no-store，不产生任何缓存，不能重用缓存的资源
2. 如果是no-cache，缓存每次都生效，先缓存本地，但命中缓存后必须与server验证缓存的新鲜度
3. 看能否被中继缓存，public被所有用户缓存,包括中继缓存server，private只能被终端浏览器缓存
4. 再判断max-age，如果超过了最大缓存时间，在缓存有效期内命中缓存，则直接读取本地的缓存资源；过期之后和server协商缓存

**协商缓存：**
当第一次请求时server的响应头中没有Cache-Control和Expires，或者过期，或者为no-cache时，则浏览器第二次请求时就会与服务器协商

1. 如果缓存和server中资源最新版本一致，就无需下载该资源，直接返回304 Not Modified
2. 如果浏览器中的缓存已经是旧版本，server就会把最新资源的完整内容返回，状态码200

判断缓存是否新鲜：

1. Last-Modified/If-Modified-Since
client首次请求资源时，server会把资源的最新修改时间Last-Modified通过响应首部发送给client，再次发送请求时，client将server返回的修改时间放在请求头If-Modified-Since中发给server，server再跟对应资源进行比对，如果资源更新了，200，如果资源是最新的，返回304，表示客户端直接用缓存即可
2. ETag/If-None-Match
类似，Etag是根据资源内容进行hash，生成一个信息摘要，只要资源有变化，ETag就发生巨变，通过摘要信息比对，就可确定缓存是否为最新，精确度更高。

流程如下：
1. 用户请求资源，判断是否存在缓存
2. 如果不存在，向server请求资源
3. server响应请求，缓存协商，返回展示资源
4. 如果存在缓存，判断缓存是否过期，如果未过期则直接使用缓存，返回展示资源
5. 如果缓存过期（Expires，Cache-Control:max-age），进行协商缓存
6. 先判断ETag，向服务器请求If-None-Match，根据返回200还是304,判断是否读取本地缓存
7. 如果没有ETag，判断Last-Modified，向服务器请求If-Modified-Since，根据200还是304判断

第 35 题：浏览器缓存读取规则
缓存可以减少网络 IO 消耗，提高访问速度。浏览器缓存是一种操作简单、效果显著的前端性能优化手段
很多时候，大家倾向于将浏览器缓存简单地理解为“HTTP 缓存”。
但事实上，浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下：

可以分成
- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

那请求的时候 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache中？

- from memory cache 从内存中拉取的缓存
- from disk cache 从磁盘上拉取的缓存

css文件会缓存到磁盘上，html.js,img等文件都会在内存和磁盘进行缓存，当刷新页面时，除了在特定的资源中返回头中写入cache-contorl: no-cache或者no-store的情况下都会直接从缓存中拉取资源，会在size中显示from memory cache，而css文件则显示from disk cache, 但是 no-cache验证没有过期，则还会返回304进行读取缓存，只是到原服务器进行了一个验证。

- 浏览器打开一个页面前端缓存了哪些东西？

浏览器的缓存机制可分为强缓存和协商缓存，服务端可以在响应头中增加Cache-Control/Expires来为当前资源设置缓存有效期(Cache-Control的max-age的优先级高于Expires)，浏览器再次发送请求时，会先判断缓存是否过期，如果未过期则命中强缓存，直接使用浏览器的本地缓存资源，如果已过期则使用协商缓存，协商缓存大致有以下两种方案：
(1) 唯一标识：Etag(服务端响应携带) & If-None-Match(客户端请求携带)；
(2) 最后修改时间：Last-Modified(服务端响应携带) & If-Modified-Since (客户端请求携带) ，其优先级低于Etag。
服务端判断值是否一致，如果一致，则直接返回304通知浏览器使用本地缓存，如果不一致则返回新的资源。

10.浏览器采用的缓存方案，如何选择和控制合适的缓存方案

HTML5离线缓存原理

### 200 From cache和200 OK有什么区别？

顾名思义是form cache是强缓存，不会和服务器通信，而200OK即为服务器处理结果正确。以此可以从浏览器缓存、输入url回车、刷新页面以及强制刷新等方面展开缓存方面的讲解。



### meta http-equiv="Cache-Control" content="no-cache" 设置的备要性
浏览器对html页会进行一个自动缓存，但是正常刷新情况下，如果用nginx做一个静态资源的情况下，都会进行一个304的重新向服务端进行一个资源是否改动的验证，如果没有改动则进行一个304的缓存利用

当关闭浏览器进程的时候，缓存在内存中的资源会随着浏览器的关闭一起清除，当再次打开浏览器的时候会从磁盘上读取缓存，这时候如果没有设置meta http-equiv="Cache-Control" content="no-cache"，当打开浏览器再次访问的时候，html页面初次会进行浏览器的磁盘上读取就是from disk cache,那此时肯定用的还是原本旧的资源，这就是问题产生的根本，所以在加入每次都从原服务器验证资源，在打开浏览器的时候就不会出来资源没有及时更新的问题。

### 输入url到展现涉及的缓存环节

1. 地址栏网址缓存
2. 检查HSTS预加载列表
3. DNS缓存
4. ARP（地址解析协议）缓存
5. TCP发送缓冲区&接收缓冲区
6. HTTP请求缓存（CDN节点缓存，代理服务器缓存，浏览器缓存，后端动态计算结果缓存）

- 地址栏网址缓存
输入网址时，浏览器自动补全。使用这个自动补全的网址时，会发现请求的相关的静态资源也是缓存中取得的。

注意：不论什么时候，我们获取的主页面资源，都应该是重新请求服务器而获得的，不可以使用本地浏览器的缓存。至于为什么？你看到静态资源文件名的 hash 值你就应该清楚了。

- 转换非 ASCII 的 Unicode 字符
浏览器检查输入是否含有不是 a-z，A-Z，0-9，- 或者 . 的字符；如果有的话，浏览器会对主机名部分使用 Punycode 编码

- 检查HSTS预加载列表（没试过）

HSTS（ HTTP Strict Transport Security ）国际互联网工程组织 IETE 正在推行一种新的 Web 安全协议，作用是强制客户端（如浏览器）使用 HTTPS 与服务器创建连接。

采用 HSTS 后：支持这个协议的浏览器，在输入 URL 后会检查自带的 HSTS 预加载列表（这个列表里包含了那些请求浏览器只使用 HTTPS 进行连接的域名），若网站在这个列表里，浏览器会使用 HTTPS 协议并且返回码为 307。而不支持 HSTS 的浏览器访问我们的网站，则不会产生跳转，从而提高了兼容性。这个机制对于不支持 HTTPS 的搜索引擎来说是非常友好的！

查看 HSTS 预加载列表是否存在你想访问的域名你可以在输入 edge://net-internals/#hsts，输入域名如juejin.im ，进行query，若存在会返回信息：

- DNS缓存
输入域名，按下回车后，就开始对域名进行解析。域名解析至少涉及了3个地方的缓存
  1. 浏览器的DNS缓存
  2. 操作系统中的DNS缓存
  3. 操作系统的hosts文件（可手动写入的缓存）

域名解析的具体过程：
  1. 浏览器搜索自己的DNS缓存（浏览器维护一张域名与IP地址的对应表），如果没有名字，进入下一步
  2. 搜索操作系统中的DNS缓存，如果没有命中，进入下一步
  3. 搜索操作系统的hosts文件（window环境下，维护一张域名与IP地址的对应表），如果没有命中，进入下一步
  
  1. 操作系统将域名发送至 LDNS （本地区域名服务器），LDNS 查询自己的 DNS 缓存（一般命中率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求：

  2. LDNS向 Root Name Server（根域名服务器，如com、net、im 等的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 im 域的顶级域名服务器的地址；

  3. LDNS 向 im 域的顶级域名服务器发起请求，返回 juejin.im 域名服务器地址；

  4. LDNS 向 juejin.im 域名服务器发起请求，得到 juejin.im 的 IP 地址；

  5. LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来。

**DNS Prefetch**
DNS预获取，是前端优化的一部分。前端优化中与DNS有关的有两点：
- 减少DNS的请求次数
- 进行DNS预获取

典型的一次DNS解析需要耗费20-120ms，减少DNS的解析时间和次数是很好的优化方式。

DNS Prefetching 是让具有此属性的域名，不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以该方式可以减少用户等待时间

可以通过 chrome://net-internals/#dns查找目前系统中的DNS缓存和Chrome中使用的情况

问题：
  浏览器DNS缓存的时间一般不会太长，1分钟左右，为什么不设置较长时间呢？
答：
  虽然DNS缓存可以提高获取DNS的速度，但缓存时间过长会影响DNS在IP变更时不能及时解析到最新的IP


- ARP缓存
ARP是一种用以解释地址的协议，根据通信方的IP地址就可以反查对应方的MAC地址。
ARP缓存是用来存储IP地址和MAC地址的缓冲区，是一个IP地址和MAC地址的对应表。当地址解析协议被询问一个已知 IP 地址节点的 MAC 地址时，先在 AR 缓存中查看，若存在，就直接返回与之对应的MAC地址；若不存在，才发送 ARP 请求查询。

- 动态资源缓存
后端缓存主要通过保留数据库连接，存储处理结果等方式缩短处理时间，尽快响应客户端请求。
