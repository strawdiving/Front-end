# 浏览器缓存
## 浏览器缓存机制, cookies、sessionStorage 和 localStorage 的使用和区别。
前端存储方式： cookie,localStorage,sessionStorage,Web SQL,IndexedDB

共同点：都是保存在浏览器端、且同源的

不同点：
  1. cookie，兼容性好，请求头自带cookie方便，数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。
    cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下
    但自动请求头加入cookie浪费流量，每个domain限制20个cookie，使用起来麻烦，需要自行封装
    sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。

  2. 存储大小限制不同
    cookie数据大小只有4k，sessionStorage和localStorage可以达到5M
  3. sessionStorage：仅在当前浏览器窗口关闭之前有效；页面关闭后会被清理，是会话级别的储存方式
    localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作持久数据；
    cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭
  4. 作用域不同
    sessionStorage：不能在所有同源窗口中共享，即不能在不同的浏览器窗口中共享，即使是同一个页面；
    localStorage：在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在
    cookie: 在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在

IndexedDB：NoSQL数据库，键值对存储，可以进行快速读取操作，js操作方便
### 浏览器缓存，强缓存和协商缓存（从200缓存，到cache到etag再到）
1. client向server请求资源
2. server返回资源，并通过**响应头决定缓存策略**
3. client根据响应头的缓存决策决定是否缓存资源，如果要缓存，就将响应头与资源缓存下来
4. 在client再次请求并命中资源时，此时client会去检查上次的缓存策略，根据策略的不同，是否过期等决定是直接读取本地缓存，还是和server协商缓存

**强缓存（优先级较高）：**
离不开响应头Cache-Control和Expires
- Cache-Control，优先级高于Expires，
`Cache-Control:max-age =3145250450`，用max-age控制过期时间（相对时间）
- Expires，表示过期时间（绝对时间），受限于本地时间，如果修改了本地时间，可能导致缓存失效

1. 如果是no-store，不产生任何缓存，不能重用缓存的资源
2. 如果是no-cache，缓存每次都生效，先缓存本地，但命中缓存后必须与server验证缓存的新鲜度
3. 看能否被中继缓存，public被所有用户缓存,包括中继缓存server，private只能被终端浏览器缓存
4. 再判断max-age，如果超过了最大缓存时间，在缓存有效期内命中缓存，则直接读取本地的缓存资源；过期之后和server协商缓存

**协商缓存：**
当第一次请求时server的响应头中没有Cache-Control和Expires，或者过期，或者为no-cache时，则浏览器第二次请求时就会与服务器协商

1. 如果缓存和server中资源最新版本一致，就无需下载该资源，直接返回304 Not Modified
2. 如果浏览器中的缓存已经是旧版本，server就会把最新资源的完整内容返回，状态码200

判断缓存是否新鲜：

1. Last-Modified/If-Modified-Since
client首次请求资源时，server会把资源的最新修改时间Last-Modified通过响应首部发送给client，再次发送请求时，client将server返回的修改时间放在请求头If-Modified-Since中发给server，server再跟对应资源进行比对，如果资源更新了，200，如果资源是最新的，返回304，表示客户端直接用缓存即可
2. ETag/If-None-Match
类似，Etag是根据资源内容进行hash，生成一个信息摘要，只要资源有变化，ETag就发生巨变，通过摘要信息比对，就可确定缓存是否为最新，精确度更高。

流程如下：
1. 用户请求资源，判断是否存在缓存
2. 如果不存在，向server请求资源
3. server响应请求，缓存协商，返回展示资源
4. 如果存在缓存，判断缓存是否过期，如果未过期则直接使用缓存，返回展示资源
5. 如果缓存过期（Expires，Cache-Control:max-age），进行协商缓存
6. 先判断ETag，向服务器请求If-None-Match，根据返回200还是304,判断是否读取本地缓存
7. 如果没有ETag，判断Last-Modified，向服务器请求If-Modified-Since，根据200还是304判断

第 35 题：浏览器缓存读取规则
缓存可以减少网络 IO 消耗，提高访问速度。浏览器缓存是一种操作简单、效果显著的前端性能优化手段
很多时候，大家倾向于将浏览器缓存简单地理解为“HTTP 缓存”。
但事实上，浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下：

可以分成
- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

那请求的时候 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache中？

- from memory cache 从内存中拉取的缓存
- from disk cache 从磁盘上拉取的缓存

css文件会缓存到磁盘上，html.js,img等文件都会在内存和磁盘进行缓存，当刷新页面时，除了在特定的资源中返回头中写入cache-contorl: no-cache或者no-store的情况下都会直接从缓存中拉取资源，会在size中显示from memory cache，而css文件则显示from disk cache, 但是 no-cache验证没有过期，则还会返回304进行读取缓存，只是到原服务器进行了一个验证。

- 浏览器打开一个页面前端缓存了哪些东西？

浏览器的缓存机制可分为强缓存和协商缓存，服务端可以在响应头中增加Cache-Control/Expires来为当前资源设置缓存有效期(Cache-Control的max-age的优先级高于Expires)，浏览器再次发送请求时，会先判断缓存是否过期，如果未过期则命中强缓存，直接使用浏览器的本地缓存资源，如果已过期则使用协商缓存，协商缓存大致有以下两种方案：
(1) 唯一标识：Etag(服务端响应携带) & If-None-Match(客户端请求携带)；
(2) 最后修改时间：Last-Modified(服务端响应携带) & If-Modified-Since (客户端请求携带) ，其优先级低于Etag。
服务端判断值是否一致，如果一致，则直接返回304通知浏览器使用本地缓存，如果不一致则返回新的资源。

10.浏览器采用的缓存方案，如何选择和控制合适的缓存方案

HTML5离线缓存原理

### 200 From cache和200 OK有什么区别？

顾名思义是form cache是强缓存，不会和服务器通信，而200OK即为服务器处理结果正确。以此可以从浏览器缓存、输入url回车、刷新页面以及强制刷新等方面展开缓存方面的讲解。



### meta http-equiv="Cache-Control" content="no-cache" 设置的备要性
浏览器对html页会进行一个自动缓存，但是正常刷新情况下，如果用nginx做一个静态资源的情况下，都会进行一个304的重新向服务端进行一个资源是否改动的验证，如果没有改动则进行一个304的缓存利用

当关闭浏览器进程的时候，缓存在内存中的资源会随着浏览器的关闭一起清除，当再次打开浏览器的时候会从磁盘上读取缓存，这时候如果没有设置meta http-equiv="Cache-Control" content="no-cache"，当打开浏览器再次访问的时候，html页面初次会进行浏览器的磁盘上读取就是from disk cache,那此时肯定用的还是原本旧的资源，这就是问题产生的根本，所以在加入每次都从原服务器验证资源，在打开浏览器的时候就不会出来资源没有及时更新的问题。



