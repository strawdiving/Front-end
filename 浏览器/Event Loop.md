
**浏览器对同一域名的并发连接数是有限的，通常为6个**

理解浏览器是如何处理用户输入、Web 请求和一般事件的。知道如何识别并正确实现异步代码。
# 浏览器的进程
浏览器是多进程的，主要包括以下进程：
- Browser进程：浏览器的主进程，唯一，负责创建和销毁其它进程，网络资源的下载与管理，浏览器界面的展示、前进后退等
- GPU进程：用于3D绘制等，最多一个
- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
- **浏览器渲染进程（浏览器内核）**：内部是多线程的，每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。

## 浏览器渲染进程（浏览器内核）
事件循环本质上是user agent（如浏览器端）用于协调用户交互（鼠标，键盘），脚本（如JS），渲染（如HTML DOM、CSS样式），网络等行为的一个机制。是嵌入 JavaScript 的 user agent 需要通过事件循环来与多种事件源交互，协调各类事件的机制。

浏览器渲染进程是多线程的，页面的渲染，Javascript的执行，事件循环，都在这个进程内进行：
- GUI渲染线程：负责渲染浏览器界面，当界面需要重绘（repaint）或由于某种操作引发回流（reflow）时，该线程就会执行

GUI渲染线程与Javascript引擎线程是互斥的。JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中，等到JS引擎空闲时立即被执行。所以如果JS引擎执行时间过长，会造成页面的渲染不连贯，页面渲染加载阻塞。
### 执行线程
- Javascript引擎线程：也称为Javascript内核，主线程，负责处理JS脚本程序，解析JS脚本，运行代码等（如V8引擎）
### 协助线程
浏览器为我们提供了JS引擎不具备的特性 Web API，包括DOM API，定时器，HTTP请求等特性，可以帮我们实现异步，非阻塞的行为。

- 事件触发线程：属于浏览器内核线程，主要用于控制事件，如鼠标，键盘等，当事件被触发时，就会把事件的处理函数推进事件队列（添加到待处理队列的队尾）等待JS引擎线程处理
- 定时器触发线程：主要控制setInterval和setTimeout。用来计时，计时完毕后，把定时器的处理函数推进事件队列中，等待JS引擎线程执行。W3C在HTML标准中规定，要求setTimeout中低于4ms的时间间隔算为4ms
- HTTP异步请求线程：通过XMLHttpRequest连接后，通过浏览器新开一个线程请求，监控readyState状态变更，监测到状态变更时，如果设置了该状态的回调函数，异步线程就产生状态变更事件，将该状态的回调函数再放入事件队列中，再由JS引擎执行。

当我们调用函数时，函数会被放入调用栈（也叫执行上下文栈），调用栈是JS引擎的一部分，并非浏览器特有的，是个栈数据结构，后进先出，当函数执行完毕返回时，会被弹出调用栈

## 单线程
### 为什么要引进单线程
因为浏览器要渲染DOM，JS可以修改DOM结构，JS执行时，浏览器DOM渲染停止。

如果不是单线程的，那么可以同时执行多段JS，如果这多段JS都修改DOM，会出现DOM冲突。（Web Worker会执行多线程，但web worker不能访问window对象，document对象）

**原因：避免DOM渲染的冲突**，当然，可以引入“锁”的机制来解决这些冲突，但大大提高了复杂性，所以JS从诞生开始就选择来单线程。

优点：实现比较简单，执行环境相对单纯

### 单线程的问题
JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，是指在JS引擎中负责解释和执行JS代码的线程唯一，也即在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务执行结束，后一个任务才能开始执行。但是又存在某些任务比较耗时，如IO读写等，后一个任务就不得不一直等着，会拖延整个程序的执行。常见的浏览器无响应，往往因为某段代码长时间运行，导致页面卡死。

所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。

各种浏览器事件同时触发时，会有先来后到的排队问题，决定这些事件如何排队触发的机制，就是事件循环。

采用异步编程的原因：

- JS是单线程
- 提高CPU的利用率

## 同步 & 异步
### 异步过程
主线程发起一个异步操作，相应的工作线程接受请求并告知主线程已收到（异步函数返回），主线程继续执行后面的任务，同时工作线程执行异步任务，工作线程完成异步任务后，通知主线程，主线程收到通知后，执行一定的动作（回调函数）。

## 浏览器环境下JS引擎的事件循环

事件循环的工作就是连接任务队列和调用栈，当调用栈中的任务均执行完毕出栈，调用栈为空时，事件循环会检查队列中是否存在等待执行的任务，如果有，取出队列中第一个任务，放入调用栈。执行完毕，返回其返回值，被弹出调用栈。

不同的异步任务分为两类。微任务（micro task）和宏任务(macro task)。
异步事件返回结果后放到任务队列中时，根据异步事件的类型，会被对应地放到macro task 或 micro task中。在当前执行栈为空时，主线程会查看微任务队列是否有事件存在，依次执行微任务队列中的事件对应的回调之后，再去宏任务队列中执行.

## 消息队列/事件队列（Task Queue） & 事件循环
工作线程将消息放在消息队列，主线程通过事件循环过程去取消息。

- 消息队列：先进先出的队列，里面存放各种消息
- 事件循环：指主线程重复从消息队列中取消息、执行的过程，这种机制叫事件循环机制。取一次消息并执行的过程叫一次循环。

事件循环是JS实现异步的具体解决方案。其中同步代码直接执行，异步函数先放在异步队列中，等同步函数执行完毕后，轮询执行异步队列的回调函数。

如此反复，就形成了一个循环，称为“事件循环”。

工作线程在完成任务后通知主线程是如何实现的？ ==》 消息队列和事件循环。

JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。

同步任务就是放在主线程上执行的任务，所有的同步任务在主线程上执行，形成一个执行栈;

异步任务是放在任务队列中的任务。异步任务有了运行结果就会在任务队列中放置一个事件；消息就是注册异步任务时添加的回调函数。消息队列中的每条消息实际上都对应一个事件。如DOM事件addEventListener，就是异步过程的发起函数，事件监听器函数就是异步的回调函数。

JS引擎遇到一个异步事件后，不会一直等待其返回结果，而是将这个事件挂起，继续执行栈中的其他任务。当一个异步事件返回结果后，js将这个事件加入与当前执行栈不同的另一个队列，即事件队列中。

事件触发时，表示异步任务完成，会将事件监听器封装成一条消息放在消息队列中，等待主线程执行。

脚本运行时先依次运行执行栈，主线程执行完当前循环中的所有代码后，会从任务队列里提取事件/消息并执行它，运行任务队列中的任务至此就完成了工作线程对主线程的通知，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，则工作线程执行完毕后，就没有必要通知主线程，也没有必要往消息队列放消息。异步函数的回调函数，一定不在当前这轮事件循环中执行。事件机制实际上就是异步过程的通知机制。

JS 执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤：
（1）所有同步任务都在主线程上执行，形成一个执行栈。
（2）主线程之外，还存在一个"任务队列"。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
（4）主线程不断重复上面的第三步。

这个过程是不断重复的，所以又叫做事件循环(Event loop)。

- “同步模式”：程序的执行顺序与任务的排列顺序是一致的、同步的；

- "异步模式"：每一个任务有一个或多个回调函数（callback），前一个任务结束后会执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。
### 消息队列
- 同步任务：按顺序执行，前一个任务完成后，才能执行后一个任务

在事件循环内部，实际上有2种类型的队列：宏任务macro队列（或只叫做任务队列），用于宏任务；微任务队列，用于微任务

从开发者角度看，主要有两个队列：
- JS外部的队列。主要是浏览器协调的各类事件的队列，即宏任务 Task Queue
- JS内部的队列，主要是JS内部执行的任务队列，即微任务 MicroTask Queue

- **宏任务/外部队列**
不直接执行，只有满足触发条件时，相关线程才将该异步任务推进任务队列中，如DOM事件，异步Ajax等
包括：
<!-- - DOM操作（页面渲染）
- 用户交互（鼠标，键盘） -->
- DOM事件
- 网络请求（Ajax等）
- 定时器等（setTimeout，setInterval，setImmediate等）
<!-- - History API操作 -->

HTML标准中明确指出一个事件循环可以有一个或多个外部队列，而每个外部事件源都有一个对应的外部队列。不同事件源的队列可以有不同的优先级（如网络事件和用户交互之间，浏览器可以优先处理鼠标行为，从而让用户感觉更流畅）

- **微任务/内部队列**
微任务是ES6和Node环境下。微任务的执行在宏任务的同步任务之后，在异步任务之前。

HTML标准没有明确规定这个队列的事件源，通常认为有以下几种：
- Promise的成功（then）和失败（catch）callback
- MutationObserver
- process.nextTick

Promise属于微任务，当一个Promise解决（resolve）并且调用它的then,catch或finally方法时，这些方法里的回调被添加到微任务队列，这意味着then,catch或finally方法内回调函数不是立即被执行，本质上是为Javascript代码添加了一些异步行为。

promise对象是由关键字new和Promise构造函数来建立的，该构造函数会把一个叫做“处理器函数”的函数作为它的参数，即 new Promise(...)中的...的内容，这个“处理器函数”是在promise建立时自动执行的

.then后的内容 才是异步内容，才交给Web APIs处理，添加到微任务队列中；即，只有涉及到状态变更后才需要被执行的回调才算是微任务，如then,catch,finally

```javascript
new Promise((resolve) => {
  console.log('promise') // 同步执行
  resolve()
}).then(data => {
  console.log(data) // 异步执行
})
```
当Promise状态为pending，那么成功或失败的回调会被分别放入[[PromiseFulfillReactions]] 和 [[PromiseRejectReactions]] 中；如果状态为非pending时，回调会成为微任务。

```javascript
Promise.resolve()
  .then(() => {
    console.log("then1");
    Promise.resolve().then(() => {
      console.log("then1-1");
    });
  })
  .then(() => {
    console.log("then2");
  });
  // then1, then1-1, then2
```
链式调用中，只有前一个then的回调执行完毕后，跟着的then中的回调才会被加入到微任务队列

事件循环给予任务不同的优先级：
- 当前在调用栈（call stack）内的所有函数会被执行。当它们返回值的时候，会被从栈内弹出。
- 当调用栈是空时（主线程处于闲置状态时），（主线程会去查找事件队列是否有任务。如果有，主线程会从中取出排在第一个的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码）。所有排队的微任务会一个接一个从微任务队列中弹出进入调用栈中，然后在调用栈中被执行（微任务也能返回一个新的微任务，有效的创建无限的微任务循环）。
- （如果调用栈和微任务队列都是空的）一旦微任务队列中所有的任务被放入调用栈并且最终被弹出，事件循环会检查宏任务队列里是否还有任务，如果有，就从宏任务队列中弹出进入调用栈，被执行后从调用栈中弹出。

轮到微任务队列执行的时候，一定会先全部执行完微任务队列才会继续往下走去执行宏任务队列的任务

## 事件处理流程
1. JS线程负责处理JS代码，当遇到异步操作的时候，将这些异步操作交给Web APIs处理，本身继续向下执行
2. Web APIs将接收到的事件按一定规则添加到任务队列中，宏事件（DOM事件、Ajax事件、setTimeout事件等）添加到宏任务队列中，微事件（Promise、nextTick）添加到微任务队列中。被放入事件队列中的事件不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕
3. JS线程处理完当前的全部任务后（执行栈为空），它会先去微任务队列中获取事件，并将微任务队列中的全部事件一件一件执行完毕，直到微任务队列为空，再进行页面的渲染，此时代表一轮事件循环的过程结束。

然后再去查看宏任务队列，取出一个事件添加到执行栈中执行，开始一轮新的事件。执行完一个宏任务后，再去执行全部微任务事件（每次取完一个宏任务队列中的事件执行完毕后，都先检查微任务队列)
4. 而后不断执行3

Node与浏览器 EventLoop的差异
