## 作用域
1. 作用域
（作用域是变量以及如何通过名称访问这些变量的规则的集合。）

作用域：指程序源代码中定义变量的区域。
作用域规定了如何查找变量，也就是 **确定当前执行代码对变量的访问权限**。
Javascript采用词法作用域（lexical scopint），也就是静态作用域。即函数的作用域在函数定义时就决定
了，函数的作用域基于函数创建的位置。
```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()(); // local scope
```
函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。

执行环境：定义了变量或者函数有权访问的其他数据，决定了它们各自的行为。

变量对象：每个执行环境都有关联的变量对象，环境中定义的变量和函数都保存在该对象中。

某个执行环境中的代码执行完以后，该环境被销毁，保存在其中的所有变量和函数都被销毁。

2. 执行上下文
JS引擎创建了执行上下文栈来管理执行上下文。当Javascript引擎执行一段可执行代码时，会创建对应的执行上下文。每个执行上下文有三个重要属性：
- 变量对象
- 作用域链
- this

变量对象是和执行上下文相关的数据作用域，存储了上下文中定义的变量和函数声明。只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活。

- 全局变量对象，是全局变量的宿主，在客户端中，全局对象就是window对象
- 函数上下文，我们用活动对象来表示变量对象，活动对象是在进入函数上下文时被创建的，通过arguments属性初始化，argements属性值是Arguments对象。

**执行过程**
全局上下文的变量对象初始化是全局对象；
函数上下文的变量对象初始化只包括Arguments对象；
进入执行上下文时会给变量对象添加形参，函数声明，变量声明等初始的属性值；
在代码执行阶段，会再次修改变量对象的属性值；

分为：
1. 进入执行上下文
变量对象会包括：（1）函数的所有形参（名称和对应值组成的一个属性被创建），没有实参，属性值设为undefined
（2）函数声明（名称和对应值即函数对象组成的一个属性被创建），如果变量存在同名属性，则完全替代该属性
（3）变量声明（名称和对应值即undefined组成的一个属性被创建），如果变量名和已经声明的形参或函数相同，则变量声明不会干扰已存在的这类属性
```javascript
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;
}

foo(1);
```
进入执行上下文时，活动对象如下：
```javascript
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}
```
2. 执行代码
顺序执行代码，根据代码修改变量对象的值。代码执行后，活动对象是：
```javascript
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}
```
```javascript
function foo() {
    console.log(a);
    a = 1;
}

foo(); // Uncaught ReferenceError: a is not defined,a未通过var声明，不会被存放到AO中，到全局去找也没有，就报错

function bar() {
    a = 1;
    console.log(a);
}
bar(); // 1，全局对象已经被赋予了a属性，可以从全局找到a的值
```
```javascript
console.log(foo);

function foo(){
    console.log("foo");
}
var foo = 1;
```
会打印函数，而不是undefined。
因为进入执行上下文时，首先会处理函数声明，如果变量名和声明的形参或函数相同，变量声明不会干扰已存在的这类属性。
2. js 的作用域有几种？
作用域分为：全局作用域，函数局部作用域，以及块级作用域；
- 全局域是最外围的执行环境，web浏览器中，是window对象。全局作用域中的变量和函数，其他域的变量都可以访问；直到应用程序退出才会销毁；开始要解释执行代码时，初始化时首先向执行上下文栈压入一个全局执行上下文
- 函数域，每个函数都有自己的执行环境，当执行流进入函数内部时，函数的执行环境会被推入一个执行环境栈中，函数执行完后，控制权交给之前的执行环境，函数的执行环境销毁，只有函数中的代码才能访问函数作用域内的变量。
- 块级作用域，只有块级作用域内部的代码可以访问作用域内的变量

**作用域链：**代码在一个执行环境中执行时，会创建变量对象的一个作用域链，保证**对执行环境有权访问的所有变量和和函数的有序访问**。

作用域链最前端是代码所在环境的变量对象。

- JavaScript 引擎如何执行变量查找。
当查找变量时，从作用域链最前端(当前上下文的变量对象中查找)开始，逐级向后（父级执行上下文的变量对象中）搜索，直到找到变量或到达全局作用域（全局上下文的变量对象，即全局对象）。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

同一个作用域中的变量名必须是唯一的。一个作用域可以嵌套在另一个作用域内。如果一个作用域嵌套在另一个作用域内，最内部作用域内的代码可以访问另一个作用域的变量。

3. function Person(){}、var person = Person()、var person = new Person()区别？
- 为什么要创建静态类成员？
### 闭包
对闭包的理解,介绍闭包,闭包为什么没清除,闭包的核心是什么,闭包的使用场景,使用闭包特权函数的使用场景
1. 什么是闭包？什么时候构成闭包？闭包的实现方法？闭包的优缺点？以及如何/为什么使用
- 闭包：**有权访问另一个函数作用域中变量的函数。**
- **实现方法**：在一个函数内部创建并返回另一个（匿名）函数
- 在一个函数内部定义的函数会将包含函数（即外部函数）的变量对象添加到它的作用域链中。即使外层函数执行完毕销毁，闭包还保留着对其变量对象的引用
- 匿名函数的执行环境具有全局性，其this对象通常指向window。
- 用途：数据隐藏、内存化以及动态函数生成。

闭包：函数 + 函数能够访问的自由变量
- 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
- 在代码中引用了自由变量（自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量）

```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}

var foo = checkscope();
foo();
```
f的执行上下文维护了一个作用域链：
`fContext = {  Scope: [AO,checkScopeContext.AO,globalContext.VO] }`
因为这个作用域链，f仍然可以读取checkScopeContext.AO中的值，当f函数引用其中值的时候，即使checkScopeContext被销毁了，JS仍然会让checkScopeContext.AO活在内存中，f仍然可以通过其作用域链找到它，从而实现闭包。

缺点： 引用变量，不利于垃圾回收，占据内存
2. **this 是如何工作的，this有哪些使用场景？**
this 引用的是函数执行时所在的上下文对象,而不是函数被创建时所在的对象。（箭头函数除外）
它的值取决于调用的模式，按优先级从高到低：
- 使用new的构造函数调用模式
将会创建一个连接到该函数的prototype成员的新对象（新对象为构造函数的一个实例），同时this会被绑定到那个新对象上。

- apply,call,bind显式调用模式
将this绑定到传入的上下文参数上
- 方法调用模式
函数被保存为一个对象的属性时，即对象的方法，this被绑定到该对象。this到对象的绑定发生在调用的时候
- 函数调用模式
this被绑定到全局对象
- **.call 和 .apply ,.bind的作用，区别是什么？对this有什么影响？**
作用：**在特定的作用域中调用函数**，把函数的this对象绑定到特定的上下文对象上；
call()和apply()函数有两个参数：第一个参数都是上下文，如果上下文是null，则使用全局对象代替。

区别在于第二个参数，即传入函数的参数的形式。
call()的是实际传入的参数序列，apply()是参数组成的数组
`function.call(this,1,2,3)`，`function.apply(this,[1,2,3])`

- 请解释 Function.prototype.bind？
返回一个新的函数。第一个参数是上下文对象，作用是将函数绑定到参数中设置的上下文，即改变函数中的this对象

多个bind连接后输出的值，bind函数运行结果，自己实现bind 函数

对闭包的理解？什么时候构成闭包？闭包的实现方法？闭包的优缺点？
this有哪些使用场景？跟C,Java中的this有什么区别？如何改变this的值？

举例说明一个匿名函数的典型用例

1.理解词法作用域和动态作用域

2.理解 JavaScript的作用域和作用域链

3.理解 JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题

5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用

变量提升，从EC的VO答
