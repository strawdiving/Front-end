## SVG
SVG是一种描述性语言，编程的主要方式是通过标签和属性的搭配，其语义性侧重功能而非逻辑。开发者需要熟知各个标签和属性的功能，而无需关注底层实现。

计算机图形学所描述的最小系统仅支持点、线段、三角这三种基本图元。

SVG的如<circle>标签背后是计算机在基本图元基础上逐个像素的计算逻辑。即SVG编程的最小单元是图形而非像素。细节处理能力不足。性能的瓶颈（大量节点），使得SVG难以应对复杂的图形应用程序。

SVG只是一种矢量图形文件格式，不仅浏览器支持，很多主流系统也都支持。
SVG矢量图，可以代替一些图片，多用于图标和图表，优势在于拥有HTML的event事件，交互起来很方便
SVG是给数据就可以绘制点、线、图形的，基于XML的标记语言
SVG适用于**矢量图**，低数据量低绘制频率的场景，如图形、图表

## canvas —— “面向像素”的图形编程技术
Canvas是需要自己画点的白板, 适用于**位图**，高数据量高绘制频率的（帧率）的场景，如动画、游戏

Canvas是HTML5新增的一个元素对象，名副其实就是一个画布，浏览器js配有相应的操作api，可以不再依赖其他API或组件而直接绘图，相当于2D的API.
一般用于绘制比较复杂的动画、游戏。canvas只是一个画布，绘制上去的东西，都是转换成像素点绘制上去的，所以没有event事件。如果需要添加交互事件，需要自己手动计算绘制的对象所在的坐标以及层级。一般用于HTML游戏，动画等

准确说，canvas分为两部分，HTML中的<canvas>标签，和渲染上下文（Rendering Context），渲染上下文又分为2D和WebGL渲染上下文。

Canvas 2D 在图形的绘制层面可以视为SVG简化版，即去掉了图形，只保留路径。

Canvas 2D 渲染的基本图元只有长方形 rect，其他图形均由path完成。在path基础上封装了一些常用路径的便捷API，如直线 lineTo,圆弧arc，贝塞尔曲线 bezierCurveTo等。

对于简单图形的绘制，canvas并不如SVG便捷，所以对于数据量较小、结构简单的charts，如柱状图、饼图等，SVG是更好的技术选型。

canvas的优点在于两点：
1. 丰富的逻辑表现力。canvas相对底层的API有更大的扩展空间，且canvas支持操作（保存/恢复）画布的状态，可应对场景多样的图形应用程序。
2. 像素级的处理能力。canvas可以获取和修改每个像素点的色值，实现一些酷炫的视觉效果。

从CSS到SVG，UI脱离了CSS盒子的束缚；从SVG到canvas，UI的表现力深入到像素级。

svg和canvas的效率：渲染同一个对象,分辨率越大,canvas效率越低；节点越多,svg效率越低

## 3D
webGL 1.0标准规范于2011年发布，2007年Mozilla和Opera浏览器就实现了初始版本。

WebGL是更底层的图形编程技术。理论上更接近纯粹的计算机图形学。基本图元只包括点、线段和三角形，并且只支持1像素宽的线段，每次绘制都是像素级操作。

WebGL的每个图形均是向量和矩阵综合运算的结果。WebGL shader的计算由CPI承担，有着比CPU更强悍的计算能力。所以WebGL最佳的应用场景是数据量庞大、计算密集型程序，包括游戏、地图、WebVR,数据可视化等。

WebGL是基于Canvas的3D框架，一套用**3D画位图**的api，主要用来做3D展示、动画、游戏

WebGL是以OpenGL ES 2.0为基础的一套浏览器3D图形API(HTML5)，在编程概念上与OpenGL ES 2.0几乎是完全通用的，同样采用可编程渲染管线，也就是每个顶点的处理受到一小段 Vertex Shader 代码的控制，每个像素的绘制过程也受到一小段 Fragment Shader代码 的控制。WebGL主要是3D为主，2D的绘图要求也可以变通来实现。

WebGL无论如何都需要一个显示对象来呈现，这个对象就是Canvas。除了这个，WebGL不对Canvas有任何附加的操作API，那部分属于浏览器js支持的范畴。
他的渲染则和canvas不同，可以支持硬件加速,支持3D,可用于3D游戏的开发。很多酷炫的图形交互的3D图表,大多用WebGL来渲染的.

WebGL也继承OpenGL ES 2.0的兼容支持能力，在不同的设备上做有限的支持，需要运行时查询。

Three.js、Babylon.js、Blender4Web等是几种知名的 WebGL 开发框架，对 WebGL 基础操作做了大量的封装，可以拿来就用， 即使不了解 WebGL规范的细节。

### WebVR
WebVR对图形的要求非常苛刻，VR视角下，1像素的锯齿都会影响整体的观感；且WebVR的视角变换灵敏度远甚于鼠标和键盘，用户头部一个微小角度的转动都会触发应用程序大量的计算。
开发WebVR应用的技术栈必须具有像素级处理能力，及高性能计算能力，前端技术领域满足这两项要求的仅有WebGL.

### 数据可视化
人工智能的发展，TensorFlow，数据体量和交互场景复杂度的提升也必然推进数据可视化领域的改革，WebGL必然会取代SVG成为复杂数据可视化应用的最佳选择。

## 与新技术的融合
性能是计算密集型编程的应用架构核心要素之一，提升性能的技术和模式：Web Worker和WebAssembly

web worker用于实现多线程，且worker线程安全，是前端实现并行计算的最佳也是唯一技术选型。目前浏览器支持度比较理想，几乎成为了WebGL应用的基础技术栈。

WebAssembly能大幅提升前端的计算性能，计算密集型的图形编程是其最佳的应用场景之一。

## 工程化
相对于常规前端项目，图形编程应用在工程化实施上更具优势。图形编程是纯粹的客户端渲染并且无 SEO 需求，更利于前后端分离开发和动静资源的分离部署。数据驱动 UI 也更利于单元测试。


