## SPA整体概念

SPA是一种Web开发方法。目标：让开发出的Web应用具有原生桌面应用那样的界面效果。将桌面应用的强大能力带到跨平台、瘦客户端的Web浏览环境中。

SPA，单页面Web应用程序，相对于Adobe Flash，Java Applet，Microsoft Silverlight等，不需要额外的浏览器插件，也不需要额外学习一门新的语言，仅仅借助JS, HTML, CSS即可实现。

AJAX的不唐突式数据请求，结合Javascript的动态更新DOM以及CSS实时改变页面样式的能力，使得AJAX成为现代Web开发中的前沿技术。

### SPA简述

在SPA应用里，整个应用作为单个Web页面运行。在这种方式下，应用的表现层从服务器端脱离出来，并在浏览器端管理。

传统的Web应用程序：

每个新视图（HTML页面）请求都会导致对服务器端的双向访问。当客户端需要新数据时，会向服务器端发送请求。在服务器端，请求由表现层的某个控制器对象拦截，该控制器通过服务层与模型层交互，服务层决定完成模型层任务所需的组件。通过数据访问对象（DAO）或服务代理获取数据之后，所有必要的数据更新都将由业务层的业务逻辑产生。

控制传回到表现层，在这里选择合适的视图。展示逻辑规定新获取数据在选中视图中如何展示。通常，（服务器端的HTML源文件）结果视图是一个包含占位符的源文件，数据（及其他可能的渲染指令）将插入到占位符中。

每当控制器将请求路由至视图时，该文件表现得就像某种类型的模板，以让视图设置好占位符的数据。

数据和视图整合好以后，视图返回给浏览器，浏览器接收新的HTML页面，并通过**界面刷新**，将包含请求数据的新视图展示给用户。即**每次导航请求都会得到一个新的静态页面**。

每个新视图（HTML页面）都在服务器端构建。

| SPA特点            | 详细描述                                                     |
| ------------------ | ------------------------------------------------------------ |
| 无需刷新浏览器     | 视图并非完整的HTML页面，它们仅仅是构成屏幕可视区域的DOM的一部分。初始页面加载以后，所有创建和显示视图所需的内容将下载并准备就绪。如果后续需要新的视图，视图将在浏览器本地生成，并通过Javascrip动态关联到DOM |
| 表现逻辑位于客户端 | 表现层解耦。表现逻辑主要集中在客户端，整合HTML与数据的任务移到了客户端。客户端模板是客户端（过插入数据或其他渲染指令）产生新视图的基本手段，但它不是完整页面的HTML模板，只针对视图呈现页面的一部分。 |
| 服务端事务处理     | 渲染在客户端完成，而在业务处理时发送和接收操作只涉及数据。**通过XHR API实现异步通信，常用的数据交换格式是JSON** |

#### 以Shell页面开始

**SPA应用中，应用加载之后就不会再有整页刷新。相反，展示逻辑预先加载，并有赖于内容Region中的视图切换来展示内容。**

SPA的单页面指的是初始HTML页面，或被称为Shell（外壳页面）。它加载且仅加载一次，其充当应用程序其余部分的起始点。SPA应用中，这是唯一全页面加载的时机。应用后续部分的加载将动态并独立于Shell页面进行，无须全页面加载，不让用户感受到页面的刷新。

典型地，Shell页面在结构上保持最小化，并通常包含一个空< div>标签作为容器，容纳应用程序其它内容。

如果应用程序的可视化区域划分为几部分，则初始< div>容器标签可以包含子容器，通常被称为Region（区域），从视觉上将屏幕划分为几个逻辑区块。Region的< div>容器就是通知MV*框架插入动态内容的地方。React则是使用DOM修补（patching）的方式，而非替换特定Region。

#### 视图

SPA的页面不是传统概念上的页面（一个完整的HTML页面），当用户进行导航操作时，屏幕所呈现的貌似页面的部分，实际上是应用程序内容的独立部分（HTML代码片段），称为**视图**。

SPA中，一个完整的HTML文件包含占位符（`<div id="container"/>`），占位符对应存储在视图文件中的HTML代码片段。

1. 视图的产生

通常，作为用户导航的结果，SPA各个部分按需展示。其中每个部分的HTML骨骼构造被称为**模板（template)**，模板包含数据占位符。开发者通过Javascript的第三方库或框架（通常称为MV*框架）来绑定数据与模板（可以是一个或多个模板）。所有不在Shell页面中的屏幕内容都放入单独视图中。（**视图是数据与一个或多个模板的绑定结合体**）。

整个视图都与DOM关联。根据实际情况，作为用户导航的结果，视图要么直接位于初始< div>容器中，要么位于某个Region（初始< div>容器的子容器）中。

2. 实现无刷新的视图切换

所有的视图切换都不用刷新Shell页面。导航时，对于屏幕的特定部分，SPA视图通过DOM操作进行无缝切换，一个视图的内容仅仅只是被另一个视图的内容所替代，无须重新加载页面。

对用户而言，页面看起来发生了改变，而URL却未有变化。

在客户端创建及管理视图的任务是由MV*框架负责的。

3. 视图的更新

利用AJAX技术，SPA异步获取服务器端数据并动态插入到应用。在请求及获取服务器端数据时也不会重新加载页面，这也是原生应用的体验效果。

获取数据后，数据与HTML模板进行绑定，视图实时更新，而用户察觉不到丝毫闪烁。

| SPA优点                                  | 详细描述                                                     |
| ---------------------------------------- | ------------------------------------------------------------ |
| 桌面应用程序的呈现效果，却运行在浏览器中 | SPA应用能动态重绘屏幕的某个部分，并实时展现变化结果。SPA预先下载Web页面结构，就无需向服务器端发起破坏性的请求，体验与原生桌面应用类似。运行在浏览器环境，浏览器环境“瘦”，无处不在，标准化环境。 |
| 更少的用户等待时间                       | 更少的页面加载等待时间。SPA预先加载Shell页面及少量的支持文件，在用户导航时进行动态构建，应用启动速度很快。屏幕渲染更流畅、平滑，事务处理更轻量、快速，用户等待时间大大降低 |
| 表现层解耦                               | UI的呈现及行为处理代码（视图的创建与管理）在客户端而非服务器端。服务器端和客户端尽可能解耦。两端分别独立管理和更新 |
| 更快更轻量级的（服务端）事务处理         | 应用初始分发以后，客户端和服务器端的交互只有数据的发送和接收。异步、纯数据的事务处理使得SPA架构运行速度非常快。 |
| 更好的代码维护性                         |                                                              |

## MV*框架

在浏览器端，实现关注分离：

HTML——应用程序的脚手架，主要关注提供内容占位符的元素，规划出UI结构，并提供用户可与之交互的控件

CSS——样式表，描述UI的设计，负责外观与格式

Javascript——负责应用表现层逻辑。该层通常实现Web应用的动态特性，提供其余两层之上的行为与编程控制。

### MV*概念

表示基于浏览器的一系列框架，用于构建应用程序的关注分离。

- Model——典型的模型包含了数据、业务逻辑及验证逻辑

- View——视图即用户所见以及交互的界面，是模型数据的可视化呈现。有赖于框架其他部分（这些部分负责用户交互的更新和响应），其可以是一个简单结构；或者同样有赖于MV*实现，其也可以包含逻辑。
- *——第三部分，帮助管理模型与视图间的关系，以及模型、视图与用户间的关系。

#### MVC(模型-视图-控制器，Model-View-Controller)

 **控制器** ——是应用程序的入口点，接受来自UI控件的信号。还包含了处理用户输入的逻辑，以及基于接收到的输入，发送命令给模型以更新模型状态的处理逻辑。

与控制器的交互引发一个事件链，最终产生视图更新。

![1546590545005](C:\Users\wurenji.ZKXS\AppData\Roaming\Typora\typora-user-images\1546590545005.png)

即：**控制器处理用户输入，并发送命令更新模型状态；视图观察模型，并在模型状态发生改变时获取新数据进行视图更新；模型通知视图状态发生改变。**

#### MVP(模型-视图-表示器，Model-View-Presenter)

在MVP模式中，类似控制器的对象与视图一起表示用户界面或呈现（Presentation），模型继续表示数据管理，每个视图都由一个被称为表示器的组件来支持。

**表示器**——包含视图的展示逻辑。视图通过将职责委托给表示器，其仅仅用于响应用户交互。表示器直接访问模型以获取任何更新，并将数据更新回传给视图。**表示器在模型和视图之间扮演了中间人的角色。**

视图的详细信息抽象为接口（或基类）。 表示器与视图的抽象层交互。

![img](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1546600458314&di=ba9c428e435a227d9aba47dba9fade33&imgtype=jpg&src=http%3A%2F%2Fimg2.imgtn.bdimg.com%2Fit%2Fu%3D3726858962%2C768254488%26fm%3D214%26gp%3D0.jpg)



即：**视图是交互的主要入口点，其将动作代理给表示器；表示器如同中间人，彻底解耦视图和模型；视图更新通过视图接口来完成**

#### MVVM(模型-视图-视图模型，Model-View-ViewModel)

视图是入口点，也有一个对象位于模型和视图之间，即视图模型。

**视图模型**——是视图的模型或展示代码，其还是模型和视图之间的中间人。所有定义及管理视图的代码都包含在视图模型中。其包含了数据Property及展示逻辑。在模型中，每个需要在视图里得以反映的数据点，都映射到视图模型的对应Property上。视图模型能够掌握视图与模型的变化，并**保持两者同步** 。

视图模型提供对视图模型化的Property及逻辑。其还保持模型和视图的同步。

这些模式实现的基本思想是：在开发者的个人逻辑之外，以框架或库来管理Javascript和HTML之间的关系。

MV*库和框架 **让SPA应用绑定服务器端请求数据与视图** ，允许开发者设计UI，以让业务数据（模型）与生成的HTML“页面”（视图，用户与之交互）之间可以相互通信，但代码却分开管理。Controller，ViewModel，Presenter则是一切机制的协调者。



## 模块化编程

与依赖全局变量和函数不同的是，SPA中的Javascript代码通过**模块（Module）**来组织。模块提供了状态和/或数据封装，还有助于代码解耦及维护。

在Javascript侧，由于要处理无刷新的单页面，因此针对变量和函数的简单全局作用域无法满足现实所需。我们得将代码划分为可行的数个单元，并在被称为**模块（Module）**的函数中安置这些代码，模块具有属于自己的作用域。这种方式可以绕开不得不在全局命名空间中创建所有变量和函数的局限。

模块是分组不同功能部分的一种方式，其隐藏一些内容的同时公开其他内容。模块能限制代码的作用域。每个模块中定义的变量和函数都有其所属的局部作用域。

## 客户端路由

为了让用户掌握其导航位置，SPA通常会在设计中融入路由选择（Routing）的设计思路：借助MV*框架或第三方库的代码实现，将URL风格的路径与功能关联起来。

路径通常看起来像相对URL，其充当用户导航时到达特定视图的触发因素。路由器可以动态更新浏览器URL，并允许用户使用前进和后退按钮。

## SPA的布局设计与视图合成

## 模块间通信

## 服务器端处理

异步获取数据及重绘屏幕各部分区域的能力，是SPA应用架构的主要构成。

## 单元测试

## 客户端任务自动化



