## 单元测试

单元测试通常都会对代码行为方式进行断言。

#### 断言

断言是测试的核心，它们决定了哪些测试会通过，哪些会失败。断言是一些表述代码期望执行结果的语句，如果断言不正确，则测试失败。

### 最佳实践

- 每个单元测试都专注于特定业务相关概念

重心应该只放在我们的逻辑代码上，测试自己所写的最小可测部分代码，而非关注诸如第三方软件的bug，UI层级的测试等。

- 避免创建模糊且没有针对性的API

如果无法便捷测试业务逻辑的各个部分，就需要考虑是否要重构代码了。应该在API中为业务逻辑的每个关注点创建其自己的函数。

- 没有必须遵循的测试顺序

大多数测试工具允许将测试划分为组（或套件），应当避免包括那些在测试套件中依赖特定顺序工作的测试。单元测试在测试套件中的位置无关紧要，应当能够以任意顺序运行它们，且实现一致的相同结果。

- 单元测试应当自依赖

好的单元测试应该能够重复一致的结果，确保此效果的唯一可行途径就是让测试独立于上下文，且不依赖外部依赖。

单元测试应该能够重复，即使脱离原先编写的环境运行在另一个环境里（不管是运行在本地开发环境还是在专门机器上测试），结果都应该相同。

单元测试不该依赖任何外部系统，甚至其他的测试。为了避免依赖外部系统，可以用Mock代替外部系统。

**Mock**

Mock是带有预编程期待的对象，可以在单元测试中代替真实系统。例如，可以将Mock作为实时Web服务调用的替代品，其可以表现为系统调用，且能作出测试所需的响应。

- 每个测试的关注点应该清晰易懂

好的单元测试可以仅通过查看测试标题及注释就能快速明白其用意。

**TDD（Test-Driven Development）测试驱动开发**

通过前置单元测试，将单元测试与设计过程更多地联系在一起。刚开始的测试会失败，因为尚未编写逻辑代码；下一步是创建让测试通过所需的最少量代码，这将为新特性或增量开发一个基线；接下来，对代码不断进行重构，代码逐渐由最初的最小实现演进成良好设计、生产就绪的代码。每次重构后，测试都要重新运行。

### 测试步骤

#### 准备测试环境

1. **创建测试目录** ——常见方式是设置一个跟应用结构类似的目录结构。通常跟应用源代码分隔开来。
2. **定义测试结果页面** ——需要一个HTML页面来显示单元测试的结果（HTML中包含所有需要的文件，如测试脚本及源文件的引用）。在现实的解决方案里，更倾向于使用一个构建工具来收集所需内容

#### 创建单元测试

1. **制造断言** ——单元测试背后的思想是要断言某些逻辑是真。当运行单元测试时，每个断言得到执行，通过验证其断言来让各个单元测试成功或失败
2. **编写单元测试** ——调用API，针对预期值测试结果
3. 对测试进行分组

#### 流行的Javascript测试框架

Mocha，具备大量特性，但需要自己选择断言库，如Unit.js或Chai.js

Jasmine，关注行为驱动开发（BDD)

QUnit

# 测试相关问题
- 对代码进行测试有什么优缺点？
- 你会用什么工具测试你的代码的功能？
- 单元测试与功能/集成测试的区别是什么？
- 前端怎么做单元测试

# 前端自动化测试是干嘛的
## unit test单元测试
内容：测试项目中的单元，可以是一个函数，也可以是一个子模块
目的：自动化，驱使更好地设计（比如耦合性强的代码写单元测试会发现很难）
原理：
    相当于另外编写了一套程序，把业务逻辑中的的脚本文件当作模块引入，模拟其运行环境（例如需要的浏览器类型，全局变量等），然后使用一组或若干组覆盖不同使用场景的参数来调用想要测试的函数单元，并判断函数返回的结果是否和预期相同。

如
```javascript
function Swiper (el, options) {
    if (typeof el === 'string') {
        this.el = document.getElementById(el)
    } else {
        this.el = el
    }
    console.log('a swiper is created')
}
```
没有测试类库，可能的测试流程：
- 写个demo.html，引入上面的代码
- 测试传元素id实例化的情况
- 测试传元素本身实例化的情况
- 测试swiper其他功能
- 并且最好能在控制台上console.log一些东西，告诉我当前正在测什么，测试结果是怎么样的

1. 测试框架，就是帮助完成上面的过程：归类测试用例，输出进度，测试结果，给出报告等。

2. 断言库 —— chai, should.js, 测http的 superagent等
是让我们除了 "===" 之外，还有其他很多手段去做比较，而且可读性很强，如`this.obj.should.have.property('id').which.is.a.Number()`
3. karma
是一个测试工具，让你的代码在浏览器环境下测试。为前端自动化测试提供了跨浏览器测试的能力，可以自动在Chrome,Firefox,IE等主流浏览器依次跑完测试用例，同时也支持headless浏览器(入phantomJs)中运行测试用例，暴露浏览器兼容问题。

webpack+babel可以主动为想要适配的浏览器提供转码和polyfill引入能力，而Karma可以为最终的结果提供验证能力。

需要它的原因在于，你的代码可能是设计在浏览器端执行的，在node环境下测试可能有些bug暴露不出来；如果你的代码只会运行在node端，那么你不需要用karma。

4. Mocha
前端自动化测试框架，测试框架需要解决**兼容不同风格断言库，测试用例分组，同步异步测试架构，生命周期钩子**等框架级的能力。

- 不同风格的断言库： should.js, expect.js及node核心断言模块 assert 等。
- 生命周期钩子：一般用来建立和清理环境或全局变量
before，after，beforeEach, afterEach

5. Chai
是一个断言库合集，支持should, assert, should断言语法。

6. 基于 Chai-http 的自动化接口测试
Chai-http是基于Chai扩展的插件，可用于测试与http请求相关的逻辑代码。开发中也可以利用PostMan或是DocLever来管理接口并进行接口测试。接口测试的运行方式和单元测试很类似，区别在于测试用例的写法。


### 单元测试覆盖率
单元测试的目的，是将项目拆分成小单元，每个单元测试中尽量设计case将代码逻辑中的每个分支都运行到，这样所有的单元测试跑下来，项目中的每行代码最好都被跑过一次，即覆盖率尽量靠近100%。

工具：istanbul

## end-to-end e2e测试 —— nightwatch
e2e测试，主要是测业务。绝大部分情况是指在浏览器上对某个网站进行某个操作，如登录等。

这个库提供了很多功能，来模拟人在页面上进行的操作，从而代替人的点击输入操作，来完成自动化的E2E测试。

测试很花时间，可能比写项目代码更久，且项目代码变动，测试就要改，一般只有自己开发类库对 API 的测试用例才会比较有帮助,或者开发UI库的时候，写测试比较实用。

测试能改善设计，去看Martin Fowler的测试驱动一本书。