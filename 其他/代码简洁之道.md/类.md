1. 单一职责原则(SRP)
将多个功能塞进一个类，会导致该类无法达到概念上的内聚，并经常不得不进行修改。

最小化对一个类需要修改的次数是非常有必要的。当一个类有太多太杂的功能，当你对其中一小部分进行修改时，很可能对代码库中依赖该类的其他模块造成影响。

2. 开/闭原则（OCP）
代码实体（类，模块，函数等）应该易于扩展，难于修改。即我们应允许用户方便的扩展我们代码模块的功能，而不需要打开js文件源码手动对其修改。
如：
```javascript
class AjaxRequester {
  constructor() {
    this.HTTP_METHODS = ['POST', 'PUT', 'GET'];
  }

  get(url) {
    // ...
  }

  addHTTPMethod(method) {
    this.HTTP_METHODS.push(method);
  }
}
```

3. 利斯科夫替代原则 (LSP)
子类对象应该能够替换其超类对象被使用。

也就是说，如果有一个父类和子类，当采用子类替换父类时不应该产生错误的结果。

4. 接口隔离原则（ISP）
客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。

在JS中，当一个类需要许多参数设置才能生成一个对象时，或许大多数时候不需要设置这么多的参数。能减少对配置参数数量的需求是有益的。

5. 依赖反转原则（DIP）
- 高层模块不应该依赖于低层模块
- 抽象接口应该脱离具体实现，具体实现应该依赖于抽象接口

6. 使用ES6的class而不是ES5的Function
ES5的Function在继承、构造和方法定义方面可读性比较差。当需要继承时，优先选用class

当在需要更大更复杂的对象时，优先选择更小的function

7. 使用方法链

在class的函数中返回this，能够方便的将类需要执行的多个方法链接起来。
8. 优先使用组合模式而非继承

继承什么时候更有优势：
- 继承关系表现为“是一个”而非“有一个”（如动物-》人和用户-》用户细节）
- 可以复用基类的代码（human可以是animal的一种）
- 希望基类改变时所有派生类都受到影响